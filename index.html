<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 8.6.9">
<title>FAI Guide (Fully Automatic Installation)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


/*
 * Theme specific overrides of the preceding (asciidoc.css) CSS.
 *
 */
body {
  font-family: Garamond, Georgia, serif;
  font-size: 17px;
  color: #3E4349;
  line-height: 1.3em;
}
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Garmond, Georgia, serif;
  font-weight: normal;
  border-bottom-width: 0;
  color: #3E4349;
}
div.title, caption.title { color: #596673; font-weight: bold; }
h1 { font-size: 240%; }
h2 { font-size: 180%; }
h3 { font-size: 150%; }
h4 { font-size: 130%; }
h5 { font-size: 115%; }
h6 { font-size: 100%; }
#header h1 { margin-top: 0; }
#toc {
  color: #444444;
  line-height: 1.5;
  padding-top: 1.5em;
}
#toctitle {
  font-size: 20px;
}
#toc a {
    border-bottom: 1px dotted #999999;
    color: #444444 !important;
    text-decoration: none !important;
}
#toc a:hover {
    border-bottom: 1px solid #6D4100;
    color: #6D4100 !important;
    text-decoration: none !important;
}
div.toclevel1 { margin-top: 0.2em; font-size: 16px; }
div.toclevel2 { margin-top: 0.15em; font-size: 14px; }
em, dt, td.hdlist1 { color: black; }
strong { color: #3E4349; }
a { color: #004B6B; text-decoration: none; border-bottom: 1px dotted #004B6B; }
a:visited { color: #615FA0; border-bottom: 1px dotted #615FA0; }
a:hover { color: #6D4100; border-bottom: 1px solid #6D4100; }
div.tableblock > table, table.tableblock { border: 3px solid #E8E8E8; }
th.tableblock, td.tableblock { border: 1px solid #E8E8E8; }
ul > li > * { color: #3E4349; }
pre, tt, .monospaced { font-family: Consolas,Menlo,'Deja Vu Sans Mono','Bitstream Vera Sans Mono',monospace; }
tt, .monospaced { font-size: 0.9em; color: black;
}
div.exampleblock > div.content, div.sidebarblock > div.content, div.listingblock > div.content { border-width: 0 0 0 3px; border-color: #E8E8E8; }
div.verseblock { border-left-width: 0; margin-left: 3em; }
div.quoteblock { border-left-width: 3px; margin-left: 0; margin-right: 0;}
div.admonitionblock td.content { border-left: 3px solid #E8E8E8; }


@media screen {
  body {
    max-width: 50em; /* approximately 80 characters wide */
    margin-left: 16em;
  }

  #toc {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 13em;
    padding: 0.5em;
    padding-bottom: 1.5em;
    margin: 0;
    overflow: auto;
    border-right: 3px solid #f8f8f8;
    background-color: white;
  }

  #toc .toclevel1 {
    margin-top: 0.5em;
  }

  #toc .toclevel2 {
    margin-top: 0.25em;
    display: list-item;
    color: #aaaaaa;
  }

  #toctitle {
    margin-top: 0.5em;
  }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(3);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Guide FAI (Installation entièrement automatique)</h1>
<span id="author">Thomas Lange</span><br>
<span id="email"><code>&lt;<a href="mailto:lange@informatik.uni-koeln.de">lange@informatik.uni-koeln.de</a>&gt;</code></span><br>
<span id="revnumber">version 5.3,</span>
<span id="revdate">16 Jan 2017</span>
<span id="author">Traduction française: Jean-Baptiste Masurel</span><br>
<div id="toc">
  <div id="toctitle">Table des matières</div>
  <noscript><p><b>JavaScript doit être activé dans votre navigateur pour afficher la table des matières.</b></p></noscript>
<div class="toclevel1"><a href="#_abstract">Abstrait</a></div><div class="toclevel1"><a href="#_a_id_introduction_a_introduction">Introduction</a></div><div class="toclevel2"><a href="#_a_id_availability_a_availability">Disponibilité</a></div><div class="toclevel2"><a href="#_a_id_motivation_a_motivation">Motivation</a></div><div class="toclevel2"><a href="#_a_id_work_a_how_does_fai_work">Comment fonctionne FAI</a></div><div class="toclevel2"><a href="#_a_id_features_a_features">Caractéristiques</a></div><div class="toclevel2"><a href="#_installation_times">Le temps de l'installation</a></div><div class="toclevel1"><a href="#_a_id_impatient_a_quickstart_for_the_impatient_user">Quickstart - Pour l'utilisateur impatient</a></div><div class="toclevel2"><a href="#_a_id_first_a_my_first_installation">Ma première installation</a></div><div class="toclevel2"><a href="#_a_id_cdserver_a_my_first_server_installation">Mon premier serveur d'installation</a></div><div class="toclevel1"><a href="#_a_id_overview_a_overview_and_concepts">Vue d'ensemble et concepts</a></div><div class="toclevel2"><a href="#_a_id_terms_a_important_terms"> Conditions Générales</a></div><div class="toclevel2"><a href="#_a_id_classc_a_the_class_concept">Le concept de classe</a></div><div class="toclevel1"><a href="#_a_id_setup_a_setup_your_faiserver">Configurer votre faiserver</a></div><div class="toclevel2"><a href="#_install_the_fai_packages">Installer les paquetages FAI</a></div><div class="toclevel2"><a href="#_create_the_nfsroot">Créez le nfsroot</a></div><div class="toclevel2"><a href="#_creating_the_configuration_space">Création de l'espace de configuration</a></div><div class="toclevel2"><a href="#_configure_the_network_daemons">Configurer les démons réseau</a></div><div class="toclevel3"><a href="#_a_id_bootdhcp_a_configuration_of_the_dhcp_daemon">Configuration du démon DHCP</a></div><div class="toclevel3"><a href="#_adding_a_host_entry_to_dhcp">Ajout d'une entrée d'hôte au DHCP</a></div><div class="toclevel3"><a href="#_tftp">TFTP</a></div><div class="toclevel3"><a href="#_nfs">NFS</a></div><div class="toclevel2"><a href="#_creating_the_pxelinux_configuration">Créer la configuration PXELINUX</a></div><div class="toclevel2"><a href="#_a_id_custom_server_a_custom_server">Serveur personnalisé</a></div><div class="toclevel1"><a href="#_a_id_plan_a_plan_your_installation">Planifiez votre installation</a></div><div class="toclevel2"><a href="#_a_id_c3_a_the_configuration_space_and_its_subdirectories">L'espace de configuration et ses sous-répertoires</a></div><div class="toclevel2"><a href="#_a_id_defining_classes_a_defining_classes">Définition des classes</a></div><div class="toclevel2"><a href="#_a_id_classvariables_a_defining_variables">Définition des variables</a></div><div class="toclevel2"><a href="#_a_id_diskconfig_a_hard_disk_configuration">Configuration du disque dur</a></div><div class="toclevel2"><a href="#_a_id_extrbase_a_extract_base_file">Extraction du fichier de base</a></div><div class="toclevel2"><a href="#_a_id_debconf_a_debconf_preseeding">Présélection Debconf</a></div><div class="toclevel2"><a href="#_a_id_repository_a_access_to_the_package_repository">Accès au référentiel de paquets</a></div><div class="toclevel2"><a href="#_a_id_packageconfig_a_software_package_configuration">Configuration des paquets logiciel</a></div><div class="toclevel2"><a href="#_a_id_cscripts_a_customization_scripts"> Scripts de personnalisation</a></div><div class="toclevel3"><a href="#_a_id_shell_a_shell_scripts">Scripts shell</a></div><div class="toclevel3"><a href="#_a_id_cfengine_a_cfengine_scripts">Scripts cfengine</a></div><div class="toclevel2"><a href="#_a_id_hooks_a_hooks">Hooks</a></div><div class="toclevel2"><a href="#_a_id_faiflags_a_fai_flags">FAI flags</a></div><div class="toclevel1"><a href="#_a_id_install_a_fai_installs_your_plan"> FAI installe votre planification</a></div><div class="toclevel2"><a href="#_the_early_part_of_an_installation">La première partie d'une installation</a></div><div class="toclevel2"><a href="#_a_id_bootmesg_a_boot_messages">Messages de boot</a></div><div class="toclevel2"><a href="#_a_id_reboot_a_rebooting_the_computer_into_the_new_system">Redémarrage de l'ordinateur dans le nouveau système</a></div><div class="toclevel2"><a href="#_a_id_isetup_a_starting_fai_task_confdir">Démarrage de FAI (tâche confdir)</a></div><div class="toclevel2"><a href="#_a_id_iclass_a_defining_classes_and_variables_tasks_defclass_and_defvar">Définition de classes et de variables (tâches defclass et defvar)</a></div><div class="toclevel2"><a href="#_a_id_ipartition_a_partitioning_local_disks_creating_file_systems_task_partition">Partitionnement de disques locaux, création de systèmes de fichiers (tâches de partitionnement)</a></div><div class="toclevel2"><a href="#_a_id_ipreseed_a_debconf_preseeding_task_debconf">Préréglage Debconf (tâche debconf)</a></div><div class="toclevel2"><a href="#_a_id_ipackages_a_installing_software_packages_task_instsoft">Installation de progiciels (tâche instsoft)</a></div><div class="toclevel2"><a href="#_a_id_icscripts_a_site_specific_customization_task_configure">Personnalisation spécifique au site (task configure)</a></div><div class="toclevel2"><a href="#_a_id_isavelog_a_saving_log_files_task_savelog">Enregistrement des fichiers journaux (tâche savelog)</a></div><div class="toclevel2"><a href="#_a_id_ireboot_a_reboot_the_new_installed_system">Redémarrez le nouveau système installé</a></div><div class="toclevel1"><a href="#_a_id_advanced_a_advanced_fai_topics">Chapitre avancés de FAI</a></div><div class="toclevel2"><a href="#_a_id_checkbootp_a_checking_parameters_received_from_dhcp_servers">Vérification des paramètres reçus des serveurs DHCP</a></div><div class="toclevel2"><a href="#_a_id_fai_monitor_a_monitoring_multiple_client_installations">Surveillance de plusieurs installations clientes</a></div><div class="toclevel2"><a href="#_a_id_mac_a_collecting_ethernet_addresses_for_multiple_hosts">Collecte d'adresses Ethernet pour plusieurs hôtes</a></div><div class="toclevel3"><a href="#_debugging_the_network_traffic">Débogage du trafic réseau</a></div><div class="toclevel2"><a href="#_a_id_pxeboot_a_details_of_pxe_booting">Détails du démarrage PXE</a></div><div class="toclevel2"><a href="#_a_id_customizing_your_install_server_setup_a_customizing_your_install_server_setup">Personnalisation de la configuration de votre serveur d'installation</a></div><div class="toclevel2"><a href="#_a_id_cdboot_a_creating_a_fai_cd_or_and_usb_stick">Création d'un CD FAI ou d'une clé USB</a></div><div class="toclevel2"><a href="#_a_id_diskimage_a_creating_vm_disk_images_using_fai">Création d'images de disque VM à l'aide de FAI</a></div><div class="toclevel2"><a href="#_a_id_sysinfo_a_fai_rescue_system">Système de sauvetage FAI</a></div><div class="toclevel2"><a href="#_a_id_nonfs_a_fai_without_nfs">FAI sans NFS</a></div><div class="toclevel2"><a href="#_a_id_otherdists_a_installing_other_distributions_using_a_debian_nfsroot">Installation d'autres distributions à l'aide d'un nfsroot Debian/a></div><div class="toclevel2"><a href="#_a_id_dirinstall_a_creating_chroot_and_virtualization_environments">Création d'environnements chrooter et virtualiser</a></div><div class="toclevel2"><a href="#_a_id_softupdate_a_using_fai_for_updates">Utilisation de FAI pour les mises à jour</a></div><div class="toclevel2"><a href="#_a_id_archcross_a_how_to_install_32bit_os_from_a_64bit_os">Comment installer un système d'exploitation 32 bits à partir d'un système d'exploitation 64 bits</a></div><div class="toclevel1"><a href="#_a_id_hints_a_various_hints_and_details">Divers conseils et détails</a></div><div class="toclevel2"><a href="#_a_id_tasks_a_the_list_of_tasks">La liste des tâches</a></div><div class="toclevel2"><a href="#_a_id_itests_a_automated_tests">Tests automatisés</a></div><div class="toclevel2"><a href="#_a_id_autodiscover_a_autodiscover"> Découvrir automatiquement</a></div><div class="toclevel2"><a href="#_a_id_changeboot_a_changing_the_boot_device">Modification du périphérique d'amorçage</a></div><div class="toclevel2"><a href="#_a_id_debian_mirror_a_how_to_create_a_local_debian_mirror">Comment créer un miroir Debian local</a></div><div class="toclevel2"><a href="#_small_hints">Petits conseils</a></div><div class="toclevel2"><a href="#_flag_reboot_fai_flags">flag_reboot (FAI_FLAGS)</a></div><div class="toclevel2"><a href="#_centos_reboot">CentOS reboot</a></div><div class="toclevel2"><a href="#_a_id_logfiles_a_log_files">Fichiers journaux</a></div><div class="toclevel2"><a href="#_how_to_use_http_for_pxe_boot">Comment utiliser HTTP pour le démarrage PXE</a></div><div class="toclevel1"><a href="#_a_id_troubleshoot_a_troubleshooting">Dépannage</a></div><div class="toclevel2"><a href="#_a_id_booterror_a_boot_errors">Erreurs d'amorçage</a></div></div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_abstract">Abstrait</h2>
<div class="sectionbody">
<div class="paragraph"><p>FAI est un système non interactif permettant d'installer, de personnaliser et de gérer les configurations de systèmes et de logiciels Linux sur les ordinateurs ainsi que sur les machines virtuelles et les environnements chroot, des petits réseaux aux grandes infrastructures et clusters.</p></div>
<div class="paragraph"><p>Ce manuel décrit le logiciel d'installation entièrement automatique. Cela inclut l'installation des paquets, la configuration du serveur, la création de la configuration et la gestion des erreurs.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>     +-----------------------------------------------------------------------+
     | This manual describes FAI 5.3 but most things are also valid for 4.x. |
     +-----------------------------------------------------------------------+</code></pre>
</div></div>
<div class="paragraph"><p>(c) 2000-2017 Thomas Lange</p></div>
<div class="paragraph"><div class="title">droits d'auteur</div><p>Ce manuel est un logiciel libre; Vous pouvez le redistribuer et / ou le modifier selon les termes de la Licence Publique Générale GNU publiée par la Free Software Foundation; Soit la version 2, soit (à votre choix) toute version ultérieure.</p></div>
<div class="paragraph"><p>Ceci est distribué dans l'espoir qu'il sera utile, mais <strong>sans aucune garantie</strong> ; Sans même la garantie implicite de qualité marchande ou d'adaptation à un usage particulier. Pour plus de détails, consultez la GNU General Public License.<</p></div>
<div class="paragraph"><p>Une copie de la GNU General Public License est disponible sous la forme <em>/usr/share/common-licenses/GPL</em> dans la distribution Debian GNU/Linux ou sur le World Wide Web sur <a href="http://www.gnu.org/copyleft/gpl.html">le site GNU</a> Vous pouvez également l'obtenir en écrivant à la Free Software Foundation , Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, États-Unis.</p></div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_introduction_a_introduction"><a id="introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_availability_a_availability"><a id="availability"></a>Disponibilité</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Page d'accueil
</dt>
<dd>
<p>
<a href="http://fai-project.org/">http://fai-project.org</a>
</p>
</dd>
<dt class="hdlist1">
FAI wiki
</dt>
<dd>
<p>
<a href="http://wiki.fai-project.org/">http://wiki.fai-project.org</a>
</p>
</dd>
<dt class="hdlist1">
Téléchargement
</dt>
<dd>
<p>
<a href="http://fai-project.org/download">http://fai-project.org/download</a>
</p>
</dd>
<dt class="hdlist1">
Entrée pour <em>sources.list</em>
</dt>
<dd>
<p>
<code>deb http://fai-project.org/download jessie koeln</code>
</p>
</dd>
<dt class="hdlist1">
Pages du manuel
</dt>
<dd>
<p>
<a href="http://fai-project.org/doc/man/">http://fai-project.org/doc/man/</a>
</p>
</dd>
<dt class="hdlist1">
Liste de diffusion
</dt>
<dd>
<p>
<a href="https://lists.uni-koeln.de/mailman/listinfo/linux-fai">https://lists.uni-koeln.de/mailman/listinfo/linux-fai</a>
</p>
</dd>
<dt class="hdlist1">
Retour d'information
</dt>
<dd>
<p>
Envoyez vos commentaires et vos commentaires à <a href="mailto:fai@fai-project.org">fai@fai-project.org</a>ou à la liste de diffusion .
</p>
</dd>
<dt class="hdlist1">
Bogues
</dt>
<dd>
<p>
Utiliser le système de suivi des bogues Debian (BTS) <a href="http://bugs.debian.org/">http://bugs.debian.org</a>
</p>
</dd>
<dt class="hdlist1">
Changements visibles par l'utilisateur
</dt>
<dd>
<p>
<a href="http://fai-project.org/NEWS">http://fai-project.org/NEWS</a>
</p>
</dd>
<dt class="hdlist1">
Arbre source via git
</dt>
<dd>
<p>
git clone git://github.com/faiproject/fai.git
</p>
</dd>
<dt class="hdlist1">
Voir l'arbre source avec http
</dt>
<dd>
<p>
<a href="https://github.com/faiproject/fai">https://github.com/faiproject/fai</a>
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Les pages man incluent toujours des informations à jour et beaucoup de détails sur toutes les commandes FAI. Alors, n'oubliez pas de les lire attentivement. Lisez maintenant ce manuel, puis profitez de l'installation entièrement automatique et de votre temps économisé.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_motivation_a_motivation"><a id="motivation"></a>Motivation</h3>
<div class="paragraph"><p>Avez-vous déjà effectué des installations identiques d'un système d'exploitation à plusieurs reprises? Souhaitez-vous être en mesure d'installer un cluster Linux avec des dizaines de nœuds à lui seul?</p></div>
<div class="paragraph"><p>Répéter la même tâche encore et encore est ennuyeux - et conduira certainement à des erreurs. Aussi beaucoup de temps pourrait être sauvé si les installations ont été faites automatiquement. Un processus d'installation avec interaction manuelle n'est pas à l'échelle. Mais les grappes ont l'habitude de croître au fil des ans. Pensez à long terme plutôt que de planifier quelques mois dans l'avenir.</p></div>
<div class="paragraph"><p>En 1999, j'ai dû effectuer une installation d'un cluster Linux avec un serveur et 16 clients. Puisque j'ai eu beaucoup d'expérience en faisant des installations automatiques des systèmes d'exploitation de Solaris sur le matériel de SUN SPARC, l'idée de construire une installation automatique pour Debian est née. Solaris dispose d'une fonctionnalité d'installation automatique appelée JumpStart
<span class="footnote" data-note="Solaris 8 Advanced Installation Guide at
&lt;a href=&quot;https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf&quot;&gt;https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf&lt;/a&gt;
">[<a id="_footnoteref_1" href="#_footnote_1" title="View footnote" class="footnote">1</a>]</span>. En conjonction avec les scripts d'auto-installation de Casper Dik
<span class="footnote" data-note="&lt;a href=&quot;http://www.science.uva.nl/pub/solaris/auto-install&quot;&gt;http://www.science.uva.nl/pub/solaris/auto-install&lt;/a&gt;">[<a id="_footnoteref_2" href="#_footnote_2" title="View footnote" class="footnote">2</a>]</span>, Je pourrais sauver beaucoup de temps non seulement pour chaque nouvel ordinateur de SUN, mais aussi pour la réinstallation des postes de travail existants. Par exemple, j'ai dû construire un LAN temporaire avec quatre stations de travail SUN pour une conférence, qui a duré seulement quelques jours. J'ai retiré ces postes de travail de notre réseau de recherche habituel et mis en place une nouvelle installation pour la conférence. Quand il était terminé, j'ai simplement intégré les postes de travail dans le réseau de recherche, redémarré une seule fois, et après une demi-heure, tout était opérationnel comme avant. La configuration de tous les postes de travail était exactement la même qu'avant la conférence, car tout était effectué par le même processus d'installation. J'ai également utilisé l'installation automatique pour réinstaller un poste de travail après un disque dur endommagé avait été remplacé. Il m'a fallu deux semaines pour recevoir le nouveau disque dur, mais seulement quelques minutes après l'installation du nouveau disque, le poste de travail fonctionnait comme avant. Et c'est pourquoi j'ai choisi d'adapter cette technique à un cluster de PC sous Linux.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_work_a_how_does_fai_work"><a id="work"></a>Comment fonctionne FAI</h3>
<div class="paragraph"><p>Le client d'installation qui sera installé à l'aide de FAI, est démarré via une carte réseau ou à partir d'un CD ou d'une clé USB. Il obtient une adresse IP et démarre un noyau Linux qui monte son système de fichiers racine via NFS (nfsroot) du serveur d'installation. Une fois le noyau démarré, le script de démarrage FAI exécute l'installation automatique qui n'a pas besoin d'interaction. Tout d'abord, les disques durs seront partitionnés, les systèmes de fichiers seront créés et des progiciels seront ensuite installés. Après cela, le nouveau système d'exploitation installé est configuré selon vos besoins locaux en utilisant quelques scripts. Enfin, le nouveau système d'exploitation sera démarré à partir du disque local.</p></div>
<div class="paragraph"><p>Les détails sur la façon d'installer l'ordinateur (la configuration) sont stockés dans l'espace de configuration du serveur d'installation. Les fichiers de configuration sont partagés entre des groupes d'ordinateurs s'ils sont similaires en utilisant le concept de classe. Vous n'avez donc pas besoin de créer une configuration pour chaque nouvel hôte. Par conséquent, FAI est une méthode évolutive pour installer un gros cluster avec un grand nombre de nœuds même si leur configuration n'est pas identique.</p></div>
<div class="paragraph"><p>FAI peut également être utilisé comme un système de sauvetage ou pour l'inventaire matériel. Vous pouvez démarrer votre ordinateur, mais il n'effectuera pas une installation. Au lieu de cela, il exécutera un Debian GNU / Linux entièrement fonctionnel sans utiliser les disques durs locaux. Ensuite, vous pouvez effectuer une connexion à distance et sauvegarder ou restaurer une partition de disque, vérifier un système de fichiers, inspecter le matériel ou effectuer toute autre tâche.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_features_a_features"><a id="features"></a>Caractéristiques</h3>
<div class="ulist"><ul>
<li>
<p>
Une installation entièrement automatisée peut être effectuée.
</p>
</li>
<li>
<p>
Très rapide installation sans surveillance.
</p>
</li>
<li>
<p>
Système flexible grâce à un concept de classe simple.
</p>
</li>
<li>
<p>
Mise à jour des systèmes en cours d'exécution sans réinstallation.
</p>
</li>
<li>
<p>
Création facile d'un environnement de virtualisation ou d'un chroot
</p>
</li>
<li>
<p>
Les hôtes peuvent démarrer à partir d'une carte réseau, d'un CD, d'une clé USB.
</p>
</li>
<li>
<p>
Création simple d'un CD d'installation ou d'une clé USB.
</p>
</li>
<li>
<p>
PXE avec la méthode de démarrage DHCP est pris en charge.
</p>
</li>
<li>
<p>
ReiserFS, ext3 / ext4, btrfs et support de système de fichiers XFS.
</p>
</li>
<li>
<p>
Support logiciel RAID et LVM.
</p>
</li>
<li>
<p>
Détection automatique du matériel.
</p>
</li>
<li>
<p>
Vous pouvez déployer Debian, Ubuntu, CentOS, SuSE, Scientific Linux
</p>
</li>
<li>
<p>
Connexion à distance via ssh lors du processus d'installation possible.
</p>
</li>
<li>
<p>
Toutes les configurations similaires sont partagées entre tous les clients d'installation.
</p>
</li>
<li>
<p>
Les fichiers journaux de toutes les installations sont enregistrés sur le serveur d'installation.
</p>
</li>
<li>
<p>
Les scripts Shell, Perl, Python, Ruby, expect et CFEngine sont pris en charge lors de l'étape de personnalisation.
</p>
</li>
<li>
<p>
Prise en charge de nombreux protocoles comme NFS, FTP, HTTP, git
</p>
</li>
<li>
<p>
Peut être utilisé comme un système de sauvetage et pour l'inventaire matériel.
</p>
</li>
<li>
<p>
Prise en charge du client sans disque.
</p>
</li>
<li>
<p>
Ajoutez facilement vos propres fonctions via des hooks ou modifiez le comportement par défaut.
</p>
</li>
<li>
<p>
Clonage de machines utilisant des images de disque est pris en charge
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_installation_times">Le temps de l'installation</h3>
<div class="paragraph"><p>Le temps d'installation est déterminé par la quantité de logiciel et la vitesse du disque dur. Voici quelques exemples de temps. Tous les clients d'installation avaient une carte réseau 1Gbit installée.</p></div>
<div class="tableblock">
<table rules="all" frame="border" cellspacing="0" cellpadding="4" width="80%">
<colgroup><col width="26%">
<col width="13%">
<col width="20%">
<col width="26%">
<col width="13%">
</colgroup><thead>
<tr>
<th align="left" valign="top"> CPU  </th>
<th align="center" valign="top">  RAM </th>
<th align="left" valign="top">   Disque    </th>
<th align="right" valign="top">   Logiciel installé  </th>
<th align="right" valign="top"> temps</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">i7-3770T 2.50GHz</p></td>
<td align="center" valign="top"><p class="table">8GB</p></td>
<td align="left" valign="top"><p class="table">Disque SSD</p></td>
<td align="right" valign="top"><p class="table">6 GB de logiciel</p></td>
<td align="right" valign="top"><p class="table">8.5 min</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Core-i7 3.2GHz</p></td>
<td align="center" valign="top"><p class="table">6GB</p></td>
<td align="left" valign="top"><p class="table">Disque SATA</p></td>
<td align="right" valign="top"><p class="table">4.3GB de logiciel</p></td>
<td align="right" valign="top"><p class="table">7 min</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Core-i7 3.2GHz</p></td>
<td align="center" valign="top"><p class="table">6GB</p></td>
<td align="left" valign="top"><p class="table">Disque SATA</p></td>
<td align="right" valign="top"><p class="table">471 MB de logiciel</p></td>
<td align="right" valign="top"><p class="table">77sec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Intel Core2 Duo</p></td>
<td align="center" valign="top"><p class="table">2GB</p></td>
<td align="left" valign="top"><p class="table">Disque SATA</p></td>
<td align="right" valign="top"><p class="table">3 GB de logiciel</p></td>
<td align="right" valign="top"><p class="table">14 min</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_impatient_a_quickstart_for_the_impatient_user"><a id="impatient"></a>Quickstart - Pour l'utilisateur impatient</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_first_a_my_first_installation"><a id="first"></a>Ma première installation</h3>
<div class="paragraph"><p>Sans plus tarder, cette section fournira une démonstration rapide et facile d'une installation entièrement automatique à l'aide du CD FAI et d'une machine virtuelle.</p></div>
<div class="paragraph"><p>Il suffit de télécharger l' image ISO du CD à partir de <a href="http://fai-project.org/fai-cd">http://fai-project.org/fai-cd</a>  et de démarrer votre VM à l'aide de ce CD. Vous verrez un menu grub où vous pouvez choisir parmi différents types d'installation.</p></div>
<div class="paragraph"><p>Cette installation s'exécutera sans serveur d'installation. L'installation du CD est identique à celle exécutée dans un environnement réseau à l'aide du serveur d'installation FAI.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cdserver_a_my_first_server_installation"><a id="cdserver"></a>Mon premier serveur d'installation</h3>
<div class="paragraph"><p>S'il vous plaît noter, si vous avez l'intention d'utiliser QEMU/KVM, vous devez avoir qemu-kvm qemu-utils bridge-utils installés sur la machine à utiliser fai-mk-network et fai-kvm<span class="footnote" data-note="fai-kvm a besoin de beaucoup de ram pour la vm, à cause de la mise en cache de /var, 2GB sont OK">[<a id="_footnoteref_3" href="#_footnote_3" title="View footnote" class="footnote">3</a>]</span>.</p></div>
<div class="paragraph"><p>Vous pouvez le faire via</p></div>
<div class="listingblock">
<div class="content">
<pre><code># apt-get install qemu-kvm qemu-utils bridge-utils</code></pre>
</div></div>
<div class="paragraph"><p>Si vous avez l'intention d'utiliser VMware ou VirtualBox, assurez-vous que votre client utilise une connexion réseau pontée. En outre, il n'est pas possible d'utiliser des interfaces réseau pontées via le réseau sans fil, car la plupart des cartes réseau WiFi ne prennent pas en charge cette fonctionnalité.</p></div>
<div class="paragraph"><p>our configurer votre propre serveur FAI, nous vous recommandons de créer un réseau de test sur votre ordinateur et d'utiliser KVM. Pour créer ce réseau privé, il ya le script <code>fai-mk-network</code> (dans le paquet fai-server). Il configure un pont logiciel avec plusieurs dispositifs de dérivation qui appartiennent à l'utilisateur<code>&lt;username&gt;</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-mk-network &lt;username&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Après cela, vous pouvez utiliser fai-kvm (-h vous aidera) pour démarrer des machines virtuelles en utilisant KVM qui sont connectés à ce réseau privé. Fais attention. Par défaut, fai-kvm créera les images de disque pour les machines <code>/tmp</code>, qui est un disque RAM sur la plupart des systèmes. Il n'y a aucun problème à créer une image de disque vide de 20G dans /tmp (même si cette partition est de 4 Go de taille), mais alors que la VM écrit des données sur son disque, cela commencera à consommer de l'espace dans <code>/tmp</code>.</p></div>
<div class="paragraph"><p>Démarrez le premier hôte virtuel, qui deviendra le serveur FAI
<span class="footnote" data-note="Cette installation consommera environ 2 Go d'espace dans 
&lt;code&gt;/tmp&lt;/code&gt;.">[<a id="_footnoteref_4" href="#_footnote_4" title="View footnote" class="footnote">4</a>]</span>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -s20 -u 1 cd fai-cd.iso</code></pre>
</div></div>
<div class="paragraph"><p>Dans le menu grub faiserver,<code>faiserver, fixed IP</code>. Cela va installer un hôte appelé faiserver avec IP 192.168.33.250 qui contient tous les logiciels nécessaires pour un serveur FAI. Il configurera également un cache de paquets local (en utilisant apt-cacher-ng). Une fois l'installation terminée, redémarrez la machine. Lors du premier démarrage du nouveau système, il configurera automatiquement le nfsroot. Cela peut prendre quelques minutes.</p></div>
<div class="paragraph"><p>Après cela, vous pouvez démarrer des hôtes supplémentaires en utilisant le démarrage réseau. Pour chaque nouvel hôte, vous devez utiliser une valeur différente pour <code>-u</code>, qui sera utilisée pour générer des adresses MAC différentes et utiliser des noms de fichier d'image de disque différents.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -u 2 pxe</code></pre>
</div></div>
<div class="paragraph"><p>Ces clients d'installation vous montreront un menu, où vous pouvez sélectionner le type d'installation que vous souhaitez effectuer. Si le client d'installation ne trouve pas le serveur, c'est généralement parce que fai-monitor ne fonctionne plus. Cela peut se produire si vous redémarrez le faiserver après l'installation. Pour remédier à cela, exécutez simplement fai-monitor sur le faiserver et relancez le démarrage du client.</p></div>
<div class="paragraph"><p>Un autre client pourrait être lancé avec:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-kvm -Vn -u 3 pxe</code></pre>
</div></div>
<div class="paragraph"><p>Vous pouvez démarrer autant de machines dans le réseau que les périphériques de prise sont disponibles. Toutes ces machines peuvent se connecter à l'Internet extérieur, mais sont seulement accessibles à partir de votre machine hôte.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_overview_a_overview_and_concepts"><a id="overview"></a>Vue d'ensemble et concepts</h2>
<div class="sectionbody">
<div class="paragraph"><p>FAI est un système non interactif permettant d'installer, de personnaliser et de gérer les configurations de systèmes et de logiciels Linux sur les ordinateurs ainsi que sur les machines virtuelles et les environnements chroot, des petits réseaux aux grandes infrastructures et clusters. Vous pouvez prendre un ou plusieurs PC vierges, mettre sous tension et après quelques minutes, Linux est installé, configuré et exécuté sur l'ensemble du cluster, sans aucune interaction nécessaire. Ainsi, il s'agit d'une méthode évolutive pour installer et mettre à jour un cluster sans surveillance avec peu d'efforts impliqués. FAI utilise le système d'exploitation Linux et une collection de scripts shell et Perl pour le processus d'installation. Les modifications apportées aux fichiers de configuration du système d'exploitation peuvent être effectuées par CFEngine, shell (bash et zsh), Perl, Python, Ruby et attendent des scripts.</p></div>
<div class="paragraph"><p>Le groupe cible de FAI sont des administrateurs système qui doivent installer Linux sur une ou même des centaines d'ordinateurs. Parce qu'il s'agit d'un outil d'installation à usage général, il peut être utilisé pour l'installation d'un cluster Beowulf, d'une batterie de rendu ou d'un laboratoire Linux ou d'une salle de classe. De plus, des réseaux Linux de grande envergure avec différents matériels ou différentes exigences d'installation sont faciles à établir à l'aide de FAI. Mais n'oubliez pas de planifier votre installation. Le chapitre<a href="#plan">[plan]</a>contient quelques conseils utiles pour ce sujet.</p></div>
<div class="sect2">
<h3 id="_a_id_terms_a_important_terms"><a id="terms"></a>Conditions Générales</h3>
<div class="paragraph"><p>Premièrement, certains termes utilisés dans ce manuel sont décrits.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Installer le serveur
</dt>
<dd>
<p>
Il fournit les services DHCP, TFTP et NFS ainsi que les données de configuration pour tous les clients d'installation. Dans les exemples de ce manuel, cet hôte s'appelle <em>faiserver</em>. L'hôte où le package <em>fai-server</em> est installé.
</p>
</dd>
<dt class="hdlist1">
Installer le client
</dt>
<dd>
<p>
n hôte qui sera installé à l'aide de FAI et une configuration fournie par le serveur d'installation. Aussi appelé client pour courte. Dans ce manuel, les hôtes d'exemple sont appelés <em>demohost, xfcehost, gnomehost …</em>
Cet ordinateur doit démarrer à partir de son interface réseau à l'aide de PXE.
</p>
</dd>
<dt class="hdlist1">
Espace de configuration
</dt>
<dd>
<p>
Une structure de sous-répertoire contenant plusieurs fichiers. Ces fichiers décrivent les détails de la manière dont l'installation des clients sera effectuée. Toutes les données de configuration sont stockées ici. Il est également appelé config space pour le court. Il comprend des informations sur:
</p>
<div class="ulist"><ul>
<li>
<p>
Disposition du disque dur dans un format similaire à fstab
</p>
</li>
<li>
<p>
Systèmes de fichiers locaux, leurs types, points de montage et options de montage
</p>
</li>
<li>
<p>
Logiciels
</p>
</li>
<li>
<p>
Disposition du clavier, fuseau horaire, configuration Xorg, systèmes de fichiers distants, comptes utilisateurs, imprimantes ... 
</p>
</li>
</ul></div>
<div class="paragraph"><p>Le package <em>fai-doc</em>inclut un exemple d'espace de configuration incluant des exemples pour les hôtes utilisant l'environnement XFCE et GNOME parmi d'autres exemples. </p></div>
</dd>
<dt class="hdlist1">
nfsroot, NFS-Root
</dt>
<dd>
<p>
Un système de fichiers situé sur le serveur d'installation. Pendant le processus d'installation, c'est le système de fichiers complet pour les clients d'installation. Tous les clients partagent le même nfsroot, qu'ils montent en lecture seule. Le nfsroot a besoin d'environ 690 Mo d'espace disque libre. 
</p>
</dd>
<dt class="hdlist1">
TFTP
</dt>
<dd>
<p>
Sert aux clients l'initrd et le noyau utilisés pour le processus d'installation. Avec le système de fichiers servi par NFS, ces deux composent un OS temporaire dans lequel les installations sont exécutées.
</p>
</dd>
<dt class="hdlist1">
Classes FAI
</dt>
<dd>
<p>
Les classes sont des noms qui déterminent quel fichier de configuration est sélectionné. Si un client appartient à la classe WEBSERVER, il sera configuré en tant que serveur Web, la classe DESKTOP pour, par exemple, détermine les progiciels qui seront installés.
</p>
</dd>
<dt class="hdlist1">
profil
</dt>
<dd>
<p>
Un profil FAI est juste une liste de classes FAI assiged à un nom de profil, qui est étendu par une description de ce profil. C'est-à-dire que l'on peut avoir deux profils "Webserver", l'un incluant la classe APACHE, y compris la classe NGINX, pour ensuite installer la solution webserver respective. 
</p>
</dd>
<dt class="hdlist1">
les tâches
</dt>
<dd>
<p>
L'installation d'un client se compose de plusieurs parties, appelées tâches. Les tâches sont des sous-programmes prédéfinis qui effectuent une certaine partie de la FAI. Les tâches FAI suivantes sont exécutées au cours d'une installation sur les clients d'installation.
</p>
</dd>
</dl></div>
<div class="quoteblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>confdir               # get the config space
setup                 # some initialization, start sshd on demand
defclass              # define FAI classes
defvar                # define variables
action                # evaluate FAI_ACTION
install               # Start the installation
partition             # partition the harddisks, create file systems
mountdisks            # mount the file systems
extrbase              # extract the base.tar.xz
debconf               # do the Debian debconf preseeding
repository            # prepare access to the package repository
updatebase            # Set up package tools and update packages
instsoft              # install software packages
configure             # call customization scripts
finish                # do some cleanup, show installation statistics
tests                 # call tests if defined
chboot                # call fai-chboot on the install server
savelog               # save log files to local and remote location
faiend                # reboot host, eject CD if needed</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>Il s'agit de tâches qui ne sont exécutées que lorsqu'une action différente est exécutée</p></div>
<div class="literalblock">
<div class="content">
<pre><code>dirinstall           # install a chroot environment
softupdate           # only do the system configuration
sysinfo              # print detailed system information
inventory            # print short hardware inventory list</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Pour une description plus détaillée des <em>tâches</em> , voir <a href="#tasks">[tâches]</a>.</p></div>
<div class="paragraph"><p>Notez que vous n'êtes pas limité aux tâches FAI. Vous pouvez également définir des programmes ou des scripts supplémentaires qui seront exécutés à certaines occasions. On les appelle des <em>hooks</em>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
hooks
</dt>
<dd>
<p>
 Les Hooks sont des plugins, ils peuvent ajouter des fonctionnalités supplémentaires au processus d'installation ou même remplacer des tâches entières de FAI. Les Hooks sont expliqués en détail dans <a href="#hooks">[hooks]</a>.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_classc_a_the_class_concept"><a id="classc"></a>Le concept de classe</h3>
<div class="paragraph"><p>Les classes sont utilisées dans presque toutes les tâches de l'installation. Les classes déterminent quels fichiers de configuration choisir parmi une liste d'alternatives disponibles. Pour déterminer les fichiers de configuration à utiliser, FAI recherche la liste des classes définies et utilise tous les fichiers de configuration correspondant à un nom de classe<span class="footnote" data-note="Il est également possible d'utiliser uniquement le fichier de configuration avec la plus haute priorité puisque l'ordre des classes définit une priorité de bas à haut dans la liste des classes. ">[<a id="_footnoteref_5" href="#_footnote_5" title="View footnote" class="footnote">5</a>]</span>. La boucle suivante implémente cette fonction en pseudo code shell:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for class in $all_classes; do
   if [ -r $config_dir/$class ]; then      # if a file with name $class exists
      your_command $config_dir/$class      # call a command with this file name
      # exit if only the first matching file is needed
   fi
done</code></pre>
</div></div>
<div class="paragraph"><p>La caractéristique très intéressante de ceci est que vous pouvez ajouter une nouvelle alternative de configuration et elle sera automatiquement utilisée par FAI sans changer le code, si le fichier de configuration utilise un nom de classe.</p></div>
<div class="paragraph"><p>C'est parce que la boucle détecte automatiquement les nouveaux fichiers de configuration qui doivent être utilisés. L'idée d'utiliser des classes en général et d'utiliser certains fichiers correspondant à un nom de classe pour une configuration est adoptée à partir des scripts d'installation par Casper Dik pour Solaris. Cette technique s'est avérée très utile et facile.</p></div>
<div class="paragraph"><p>Vous pouvez regrouper plusieurs hôtes partageant les mêmes fichiers de configuration en utilisant la même classe. Vous pouvez également diviser l'ensemble des données de configuration pour tous les clients en plusieurs classes et les utiliser comme des briques de lego et construire la configuration entière pour un seul client en assemblant les briques ensemble.</p></div>
<div class="paragraph"><p>Si un client appartient à la classe <em>A</em>, nous disons que la classe <em>A</em>
 est définie pour ce client. Une classe n'a pas de valeur, elle est juste définie ou non définie.</p></div>
<div class="paragraph"><p>Les classes déterminent comment l'installation est effectuée. Par exemple, un client d'installation peut être configuré pour obtenir le bureau XFCE en y ajoutant simplement la classe <em>XFCE</em> . Naturellement, des configurations plus granulaires sont également possibles. Par exemple, les classes peuvent décrire comment le disque dur doit être partitionné, ils peuvent définir quels paquets logiciels seront installés ou quelles étapes de personnalisation seront exécutées.</p></div>
<div class="paragraph"><p>Souvent, une configuration client est créée en modifiant ou en ajoutant uniquement les classes auxquelles ce client appartient, ce qui rend l'installation d'un nouveau client très facile. Ainsi, aucune information supplémentaire ne doit être ajoutée à l'espace de configuration si les classes existantes suffisent à vos besoins.</p></div>
<div class="paragraph"><p>Comme vous pouvez le voir, les classes sont un pilier central de la personnalisation de votre espace de configuration et de l'installation de votre client. Pour définir vos propres classes, reportez-vous à <a href="#defining%20classes">[définition des classes]</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_setup_a_setup_your_faiserver"><a id="setup"></a>Configurer votre faiserver</h2>
<div class="sectionbody">
<div class="paragraph"><p>Voici comment configurer le serveur d'installation en quelques minutes. Les étapes suivantes sont nécessaires:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Configurer le serveur d'installation
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
Installer des packages FAI
</p>
</li>
<li>
<p>
Créez le nfsroot
</p>
</li>
<li>
<p>
Copiez les exemples dans l'espace de configuration
</p>
</li>
<li>
<p>
Configurer les démons réseau
</p>
</li>
<li>
<p>
Créer les configurations PXELINUX
</p>
</li>
</ol></div>
</li>
<li>
<p>
Démarrage et installation des clients 
</p>
</li>
</ol></div>
<div class="sect2">
<h3 id="_install_the_fai_packages">Installer les paquetages FAI</h3>
<div class="ulist"><ul>
<li>
<p>
Installez la clé du référentiel de package de projet FAI:
</p>
</li>
<li>
<p>
Ajoutez l'URL du référentiel de packages du projet FAI.
</p>
</li>
<li>
<p>
Installez le paquet <em>fai-quickstart</em> sur votre serveur d' installation .
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code># wget -O - http://fai-project.org/download/074BCDE4.asc | apt-key add -
# echo "deb http://fai-project.org/download jessie koeln" &gt; /etc/apt/sources.list.d/fai.list
# apt-get update
# aptitude install fai-quickstart</code></pre>
</div></div>
<div class="paragraph"><p>Cela installera également les paquets pour les démons de serveur DHCP, TFTP et NFS.
</p></div>
</div>
<div class="sect2">
<h3 id="_create_the_nfsroot">Créez le nfsroot</h3>
<div class="ulist"><ul>
<li>
<p>
Activez également le référentiel de package du projet FAI dans un autre fichier <em>sources.list</em>  qui est utilisé lors de la construction du nfsroot. Ensuite, activez l'utilisateur de journal pour FAI.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code># sed -i -e 's/^#deb/deb/' /etc/fai/apt/sources.list
# sed -i -e 's/#LOGUSER/LOGUSER/' /etc/fai/fai.conf</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Par défaut, FAI utilise <a href="http://httpredir.debian.org/">http://httpredir.debian.org</a> comme mirror de paquets, qui devrait tenter de trouver un référentiel de paquets rapide pour vous. <span class="footnote" data-note="Si vous souhaitez utiliser un miroir plus rapide, ajustez l'URL dans &lt;em&gt;/etc/fai/apt/sources.list&lt;/em&gt; et &lt;code&gt;FAI_DEBOOTSTRAP&lt;/code&gt; in &lt;em&gt;/etc/fai/nfsroot.conf&lt;/em&gt; avant d'appeler fai-setup.">[<a id="_footnoteref_6" href="#_footnote_6" title="View footnote" class="footnote">6</a>]</span>
 Maintenant, nous pouvons exécuter <code>fai-setup(8)</code> <span class="footnote" data-note="Ceci appellera  &lt;code&gt;fai-make-nfsroot(8)&lt;/code&gt; interne.">[<a id="_footnoteref_7" href="#_footnote_7" title="View footnote" class="footnote">7</a>]</span>
Et vérifier si tout s'est bien passé. Le fichier journal est écrit dans /var/log/fai/fai-setup.log.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code># fai-setup -v</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Ce sont quelques-unes des lignes que vous verrez à la fin de <em>fai-setup</em> . Un exemple complet de <em>fai-setup.log</em> est disponible sur la page Web FAI à l'adresse <a href="http://fai-project.org/logs/fai-setup.log">http://fai-project.org/logs/fai-setup.log</a>.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI packages and related packages inside the nfsroot:
dracut             044+189-2
dracut-network     044+189-2
fai-client         5.3.3~bpo8+2
fai-nfsroot        5.3.3~bpo8+2
fai-setup-storage  5.3.3~bpo8+2
Waiting for background jobs to finish
fai-make-nfsroot finished properly.
Log file written to /var/log/fai/fai-make-nfsroot.log
Adding line to /etc/exports: /srv/fai/config 192.168.33.250/25(async,ro,no_subtree_check)
Adding line to /etc/exports: /srv/fai/nfsroot 192.168.33.250/25(async,ro,no_subtree_check,no_root_squash)
Reloading nfs-kernel-server configuration (via systemctl): nfs-kernel-server.service.

   You have no FAI configuration space yet. Copy the simple examples with:
   cp -a /usr/share/doc/fai-doc/examples/simple/* /srv/fai/config
   Then change the configuration files to meet your local needs.
Please don't forget to fill out the FAI questionnaire after you've finished your project with FAI.

FAI setup finished.
Log file written to /var/log/fai/fai-setup.log</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Fai-setup a créé le LOGUSER, le nfsroot et a ajouté des lignes supplémentaires à <em>/etc/exports</em>. Les sous-répertoires ajoutés à <em>/etc/exports</em> sont exportés via NFS v3, de sorte que tous les clients d'installation dans le même sous-réseau peuvent les monter via NFS. 
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_creating_the_configuration_space">Création de l'espace de configuration</h3>
<div class="paragraph"><p>Installez les exemples simples dans l'espace de configuration
<span class="footnote" data-note="Ces fichiers ne doivent pas appartenir au compte racine.">[<a id="_footnoteref_8" href="#_footnote_8" title="View footnote" class="footnote">8</a>]</span>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ cp -a /usr/share/doc/fai-doc/examples/simple/* /srv/fai/config/</code></pre>
</div></div>
<div class="paragraph"><p>Ces exemples contiennent la configuration pour certains hôtes d'exemple. Selon le nom d'hôte utilisé, votre ordinateur sera configuré comme suit:/p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
demohost
</dt>
<dd>
<p>
Une machine qui n'a besoin que d'un petit disque dur. Cette machine est configurée avec le réseau en tant que client DHCP, et une démo de compte est créée. 
</p>
</dd>
<dt class="hdlist1">
xfcehost
</dt>
<dd>
<p>
Un bureau XFCE est installé, utilisant LVM, et la démo du compte est créée.
</p>
</dd>
<dt class="hdlist1">
gnomehost
</dt>
<dd>
<p>
Un bureau GNOME est installé et la démo du compte est créée. 
</p>
</dd>
<dt class="hdlist1">
other host names
</dt>
<dd>
<p>
Les hôtes disposant d'un autre nom d'hôte utiliseront notamment les classes FAIBASE, DHCPC et GRUB.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>ous les hôtes auront un compte appelé <em>demo</em> avec mot de passe <em>fai</em>. Le compte root a également le mot de passe <em>fai</em>.</p></div>
<div class="paragraph"><p>Si l'indicateur FAI <code>menu</code> est ajouté, au lieu d'utiliser le nom d'hôte pour déterminer le type d'installation, un menu est présenté et l'utilisateur peut choisir un profil pour l'installation.</p></div>
</div>
<div class="sect2">
<h3 id="_configure_the_network_daemons">Configurer les démons réseau</h3>
<div class="paragraph"><p>Pour démarrer le client d'installation via PXE, le serveur d'installation a besoin d'un DHCP et d'un démon TFTP en cours d'exécution. Le paquet <em>fai-quickstart</em> a déjà installé les progiciels pour ces daemons. En outre, le paquetage du serveur NFS pour l'exportation du nfsroot et de l'espace de configuration a été installé.</p></div>
<div class="sect3">
<h4 id="_a_id_bootdhcp_a_configuration_of_the_dhcp_daemon"><a id="bootdhcp"></a>Configuration du démon DHCP</h4>
<div class="paragraph"><p>déalement, votre faiserver doit également être votre serveur DHCP. Si ce n'est pas le cas, demandez à l'administrateur responsable du serveur DHCP de le configurer conformément à cette section. En option, il est possible d'éviter cela en utilisant la fonctionnalité <a href="#autodiscover">[autodiscover]</a> diffusée dans FAI 5.0.</p></div>
<div class="paragraph"><p>n exemple pour <code>dhcpd.conf(5)</code> est fourni avec le paquet <em>fai-doc</em>. Commencez à utiliser cet exemple et regardez toutes les options qui y sont utilisées.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cp /usr/share/doc/fai-doc/examples/etc/dhcpd.conf /etc/dhcp/</code></pre>
</div></div>
<div class="paragraph"><p>Les seules informations spécifiques FAI contenues dans ce fichier de configuration sont de définir le <code>filename</code> de <code>fai/pxelinux.0</code> et de définir <code>next-server</code> et <code>server-name</code> sur le nom de votre serveur d'install . Toutes les autres informations sont uniquement des données liées au réseau, qui est utilisé dans presque toutes les configurations DHCP. Ajustez ces paramètres de réseau à vos besoins locaux.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>deny unknown-clients;
option dhcp-max-message-size 2048;
use-host-decl-names on;

subnet 192.168.33.0 netmask 255.255.255.0 {
   option routers 192.168.33.250;
   option domain-name "my.example";
   option domain-name-servers 192.168.33.250;
   option time-servers faiserver;
   option ntp-servers faiserver;
   server-name faiserver;
   next-server faiserver;
   filename "fai/pxelinux.0";
}</code></pre>
</div></div>
<div class="paragraph"><p>Si vous apportez des modifications à la configuration DHCP, vous devez redémarrer le démon.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># /etc/init.d/isc-dhcp-server restart</code></pre>
</div></div>
<div class="paragraph"><p>Si vous disposez de plusieurs interfaces réseau, vous pouvez définir l'interface que le serveur écoutera dans<em>/etc/default/isc-dhcp-server</em>. Par défaut, le démon DHCP écrit ses messages de journalisation dans <em>/var/log/daemon.log</em>.</p></div>
</div>
<div class="sect3">
<h4 id="_adding_a_host_entry_to_dhcp">Ajout d'une entrée d'hôte au DHCP</h4>
<div class="paragraph"><p>L'adresse MAC est donnée par le matériel de la carte réseau. Pour chaque client d'installation, vous collectez son adresse MAC et la mappez à une adresse IP et à un nom d'hôte. Tout d'abord, nous ajoutons l'adresse IP et le nom d'hôte à <em>/etc/hosts</em>
<span class="footnote" data-note="Vous pouvez également ajouter ceci dans votre système de noms de domaine (DNS)">[<a id="_footnoteref_9" href="#_footnote_9" title="View footnote" class="footnote">9</a>]</span>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>192.168.33.100    demohost</code></pre>
</div></div>
<div class="paragraph"><p>Le mappage de l'adresse MAC à l'adresse IP est effectué dans le fichier <em>dhcpd.conf</em>. Ici, nous ajoutons une entrée d'hôte en <code>dhcp-edit(8)</code> la commande dhcp-edit(8) . Ici, vous devez remplacer 01:02:03:AB:CD:EF avec le MAC que vous avez trouvé.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># dhcp-edit demohost 01:02:03:AB:CD:EF</code></pre>
</div></div>
<div class="paragraph"><p>Après avoir appelé cette commande, c'est ce que l'entrée hôte dans <em>dhcpd.conf</em> ressemblera à:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>host demohost {hardware ethernet 01:02:03:AB:CD:EF;fixed-address demohost;}</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_tftp">TFTP</h4>
<div class="paragraph"><p>Normalement, vous n'avez pas besoin d'apporter de modifications à la configuration dameon TFTP. Les fichiers fournis par TFTP sont situés dans <em>/srv/tftp/fai</em>.</p></div>
</div>
<div class="sect3">
<h4 id="_nfs">NFS</h4>
<div class="paragraph"><p>La commande <code>fai-setup</code> a déjà configuré le démon NFS et ajouté quelques lignes au fichier de configuration <em>/etc/exports</em>. Il exporte les répertoires en utilisant NFS v3.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_the_pxelinux_configuration">Création de la configuration PXELINUX</h3>
<div class="paragraph"><p>La dernière étape avant de démarrer votre client pour la première fois est de spécifier quelle configuration le client doit démarrer lors de l'amorçage PXE. Nous fai-chboot(8) la commande <code>fai-chboot(8)</code> pour créer une configuration pxelinux pour chaque client d'installation. Cela comprend des informations sur le noyau, l'initrd, l'espace de configuration et certains paramètres d'amorçage. Vous devriez lire la page de manuel, qui vous donne quelques bons exemples. Voici la commande pour démarrer l'installation de l'hôte demohost.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-chboot -IFv -u nfs://faiserver/srv/fai/config demohost
Booting kernel vmlinuz-3.16.0-4-amd64
 append initrd=initrd.img-3.16.0-4-amd64 ip=dhcp
   FAI_FLAGS=verbose,sshd,createvt
   FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config

demohost has 192.168.33.100 in hex C0A82164
Writing file /srv/tftp/fai/pxelinux.cfg/C0A82164 for demohost</code></pre>
</div></div>
<div class="paragraph"><p>À ce stade, vous devriez avoir une configuration faiserver de travail et vos clients devraient démarrer dans FAI et être en mesure d'installer l'un des exemples.</p></div>
<div class="paragraph"><p>Dans la section suivante, vous pouvez lire la planification de votre installation, adapter votre espace de configuration à vos besoins particuliers et étendre FAI à l'aide de hooks.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_custom_server_a_custom_server"><a id="custom server"></a>Serveur personnalisé</h3>
<div class="paragraph"><p>Le faiseur et sa configuration n'est nullement statique. Il est possible de personnaliser et d'étendre votre serveur. Pour cela, reportez-vous à la section <a href="#Customizing%20your%20install%20server%20setup">[Personnalisation de votre installation du serveur d'installation]</a> dans <a href="#advanced">[avancé]</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_plan_a_plan_your_installation"><a id="plan"></a>Planifiez votre installation</h2>
<div class="sectionbody">
<div class="paragraph"><p>Avant de commencer votre installation, vous devriez investir beaucoup de temps dans la planification de votre installation. Une fois que vous êtes satisfait de votre concept d'installation, FAI peut faire toutes les tâches ennuyeuses et répétitives pour transformer vos plans en réalité. FAI ne peut pas faire de bonnes installations si votre concept est imparfait ou manque de quelques détails importants. Commencez à planifier l'installation en répondant aux questions suivantes:</p></div>
<div class="ulist"><ul>
<li>
<p>
Est-ce que je vais créer un cluster Beowulf ou dois-je installer des machines de bureau?
</p>
</li>
<li>
<p>
À quoi ressemble ma topologie LAN?
</p>
</li>
<li>
<p>
Ai-je un matériel uniforme? Le matériel sera-t-il uniforme à l'avenir?
</p>
</li>
<li>
<p>
Le matériel a-t-il besoin d'un noyau spécial?
</p>
</li>
<li>
<p>
Comment nommer les hôtes?
</p>
</li>
<li>
<p>
Comment les disques durs locaux doivent-ils être partitionnés?
</p>
</li>
<li>
<p>
Quelles applications seront éxécuté par les utilisateurs?
</p>
</li>
<li>
<p>
Les utilisateurs ont-ils besoin d'un système de mise en file d'attente?
</p>
</li>
<li>
<p>
Quel logiciel doit être installé?
</p>
</li>
<li>
<p>
Quels démons devraient être lancés, et à quoi devrait ressembler la configuration?
</p>
</li>
<li>
<p>
 Quels systèmes de fichiers distants doivent être montés?
</p>
</li>
<li>
<p>
  Comment effectuer les sauvegardes? How should backups be performed?
</p>
</li>
</ul></div>
<div class="paragraph"><p>Vous devez également penser à des comptes d'utilisateur, des imprimantes, un système de courrier, des travaux de cron, des cartes graphiques, l'initialisation double, le NIS, le NTP, le fuseau horaire, la disposition de clavier, l'exportation et le montage des annuaires via NFS et beaucoup d'autres choses. Donc, il ya beaucoup à faire avant de commencer une installation. Et rappelez-vous que la connaissance est le pouvoir, et c'est à vous de l'utiliser. L'installation et l'administration sont un processus et non un produit. FAI ne peut pas faire les choses que vous ne lui dites pas de faire.</p></div>
<div class="paragraph"><p>Mais vous ne devez pas commencer à partir de zéro. Examinez les fichiers et les scripts dans l'espace de configuration. Il ya beaucoup de choses que vous pouvez utiliser pour votre propre installation. Un bon article intitulé «Bootstrapping a Infrastructure» avec d'autres aspects de la construction d'une infrastructure est disponible sur <a href="http://www.infrastructures.org/papers/bootstrap/bootstrap.html">http://www.infrastructures.org/papers/bootstrap/bootstrap.html</a></p></div>
<div class="sect2">
<h3 id="_a_id_c3_a_the_configuration_space_and_its_subdirectories"><a id="c3"></a>L'espace de configuration et ses sous-répertoires</h3>
<div class="paragraph"><p>L'espace de configuration est la collection d'informations sur la façon exacte d'installer un client. L'espace de configuration central pour tous les clients d'installation se trouve sur le serveur d'installation dans <em>/srv/fai/config</em> et ses sous-répertoires. Cela sera monté par les clients d'installation dans <em>/var/lib/fai/config</em>. La commande d'installation principale <code>fai(8)</code> utilise tous ces sous-répertoires dans l'ordre indiqué sauf pour les hooks.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>class/</em>
</dt>
<dd>
<p>
Scripts et fichiers pour définir des classes et des variables.
</p>
</dd>
<dt class="hdlist1">
<em>disk_config/</em>
</dt>
<dd>
<p>
Fichiers de configuration pour le partitionnement de disque, RAID logiciel, LVM et création de système de fichiers. 
</p>
</dd>
<dt class="hdlist1">
<em>basefiles/</em>
</dt>
<dd>
<p>
Normalement , le fichier <em>base.tar.xz</em> (situé à l' intérieur du nfsroot) est extrait sur le client d'installation après la création des nouveaux systèmes de fichiers et avant l'installation du package. Il s'agit d'une image de base minimale, créée juste après avoir appelé debootstrap lors de la création du nfsroot sur le serveur d'installation. Si vous voulez installer une autre distribution que la nfsroot, vous pouvez mettre un fichier tar dans le sous-répertoire <em>basefiles/</em> et le nommer après une classe. Ensuite, la commande <code>ftar(8)</code> est utilisée pour extraire le fichier tar en fonction des classes définies. Ainsi, le fichier doit être nommé <em>CLASS.tar.xz</em>et non <em>CLASS.base.tar.xz</em> . Cela se fait dans la tâche <em>extrbase</em>. Utilisez cette option si vous souhaitez installer une autre distribution ou une version différente de celle exécutée pendant l'installation.
</p>
<div class="paragraph"><p>Ce fichier de base peut également être reçu en fonction des classes FAI via HTTP ou FTP en définissant la variable FAI_BASEFILEURL. FAI téléchargera un fichier CLASSNAME.tar.xz (ou tgz, ou tar.gz, ...) à partir de cette URL, si CLASSNAME correspond à une classe FAI.</p></div>
<div class="paragraph"><p>Exemple:</p></div>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI_BASEFILEURL=http://fai-project.org/download/basefiles</code></pre>
</div></div>
<div class="paragraph"><p>Le dossier doit prendre en charge la liste des répertoires. FAI ne recherchera pas de fichiers potentiellement correspondants.</p></div>
<div class="paragraph"><p>Voir le chapitre <a href="#otherdists">[otherdists]</a> pour savoir comment installer différentes distributions.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>debconf/</em>
</dt>
<dd>
<p>
Ce répertoire contient toutes les données <code>debconf(7)</code>. Le format est le même que celui utilisé par <code>debconf-set-selections(8)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>package_config/</em>
</dt>
<dd>
<p>
Les fichiers contenant des noms de classe contiennent des listes de progiciels à installer ou à désinstallé par <code>install_packages(8)</code>. Les fichiers nommés <em>&lt;CLASS&gt;.asc</em> sont ajoutés à la liste des clés utilisées par apt (à l'aide d'<code>apt-key(8)</code> ) pour les dépôts de paquets approuvés.
</p>
</dd>
<dt class="hdlist1">
<em>scripts/</em>
</dt>
<dd>
<p>
Scripts pour la personnalisation de votre site local. Utilisé par <code>fai-do-scripts(1)</code>.
</p>
</dd>
<dt class="hdlist1">
<em>files/</em>
</dt>
<dd>
<p>
Les Fichiers utilisés par les scripts de personnalisation. La plupart des fichiers se trouvent dans une structure de sous-arborescence qui reflète l'arborescence de répertoires ordinaire. Par exemple, les modèles de <em>nsswitch.conf</em> se trouvent dans <em>$FAI/files/etc/nsswitch.conf</em> et sont nommés en fonction des classes auxquelles ils doivent correspondre: <em>$FAI/files/etc/nsswitch.conf/NIS</em> est la version de <em>/etc/nsswitch.conf</em> à utiliser pour la classe NIS. Notez que le contenu du répertoire n'est pas automatiquement copié sur la machine cible, mais qu'il doit être explicitement copié par des scripts de personnalisation à l'aide de la commande <code>fcopy(8)</code> . 
</p>
</dd>
<dt class="hdlist1">
<em>hooks/</em>
</dt>
<dd>
<p>Les hooks sont des programmes ou des scripts définis par l'utilisateur, qui sont appelés pendant le processus d'installation. cela peut étendre ou remplacer les tâches par défaut. Le nom du fichier doit être de format <em>taskname.CLASSNAME[.sh]</em>. Un hook appelé <code>updatebase.DEBIAN</code> est exécuté avant la mise à jour de la tâche <code>updatebase</code>et seulement si l'installation du client appartient à la classe DEBIAN. 
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_defining_classes_a_defining_classes"><a id="defining classes"></a>Définition des classes</h3>
<div class="paragraph"><p>Il existe différentes possibilités pour définir des classes:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Certaines classes par défaut sont définies pour chaque hôte: DEFAULT, LAST et son nom d'hôte.
</p>
</li>
<li>
<p>
Les classes peuvent être répertoriées dans un fichier.
</p>
</li>
<li>
<p>
Les classes peuvent être dynamiquement définies par des scripts.
</p>
</li>
</ol></div>La dernière option est une fonctionnalité très intéressante, puisque ces scripts définiront des classes est un moyen très flexible. Par exemple, plusieurs classes peuvent être définies uniquement si certains matériels sont identifiés ou si une classe est définie en fonction des informations de sous-réseau du réseau.</p></div>
<div class="paragraph"><p>Tous les noms de classes, sauf le nom d'hôte, sont écrits en majuscules.ILs ne doivent pas contenir un trait d'union, un dièse, un Point-Virgule OÜ un point, mais PEUVENT contenir des characters de soulignement et des Chiffres.
</p></div>
<div class="paragraph"><p>La Tache <em>defclass</em> Appelle la commande <code>fai-class(1)</code> pour definir les classes. Tous les scripts correspondant <em>^[0-9][0-9]*</em> (qui Commencent Avec Deux Chiffres) Dans le sous-repertoire <em>$FAI/class</em> sont exécutées afin de definir les classes. Tout ce qui is affiché sur STDOUT est automatiquement definie Comme une classe. pour Plus d'informations sur Les définisions de Classe , lire les pages de manuel versent <code>fai-class(1)</code>. Le script <em>50-host-classes</em> (voir ci - dessous la version allégée) est utilisé pour les définir des classes en fonction du nom d'hôte.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># use a list of classes for our demo machines
case $HOSTNAME in
    demohost)
        echo "FAIBASE GRUB DHCPC DEMO" ;;
    xfcehost)
        echo "FAIBASE GRUB DHCPC DEMO XORG XFCE";;
    faiserver)
        echo "FAIBASE DEBIAN DHCPC DEMO FAISERVER" ;;
    *)
        echo "FAIBASE GRUB DHCPC" ;;
esac</code></pre>
</div></div>
<div class="paragraph"><p>Les noms d'hôtes doivent Rarement Être utilisé Pour Les Fichiers de configuration dans l'Espace de configuration.à la place une classe Doit Être definie et ensuite ajouté Pour un hôte Donné. En effet, la Plupart du Temps les Données de configuration ne sont pas Spécifiques au d'nom hôte, mais peut etre partager entre differants hôtes./p></div>
<div class="paragraph"><p>L'ordre des classes est important car Elle Définit la priorité des classes de Faible à Élevé.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_classvariables_a_defining_variables"><a id="classvariables"></a>Définition des Variables</h3>
<div class="paragraph"><p>La Tache <em>defvar</em> definit les variables pour l'installation du client. Les variables sont définies par les scripts Dans la <em>class/*.var</em>. Toutes les variables Globales PEUVENT Être définies Dans <em>DEFAULT.var</em>. Pour certains groupes d'hôtes utiliser un Fichier de classe ou Pour un seul hôte utiliser le Fichier <code>$HOSTNAME</code> <em>.var</em> . Ici aussi, il est utile d'étudier Tous les exemples.</p></div>
<div class="paragraph"><p>Les variables suivantes sont utilisées dans les exemples et peuvent etre aussi utiles pour votre installation:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_ACTION
</dt>
<dd>
<p>
Réglez les actions que doit éffectuer FAI. Normalement, ceci se fait par <code>fai-chboot(8)</code>. Si vous ne pouvez pas utiliser cette commande, définir la variable dans le script <em>LAST.var</em>.
</p>
</dd>
<dt class="hdlist1">
FAI_ALLOW_UNSIGNED
</dt>
<dd>
<p>
Si défini à 1, FAI Permet l'installation de de paquets à partir de référentiels non Signés.
</p>
</dd>
<dt class="hdlist1">
CONSOLEFONT
</dt>
<dd>
<p>
La police de qui est chargée lors de l'installation par <code>setfont(8)</code>.
</p>
</dd>
<dt class="hdlist1">
KEYMAP
</dt>
<dd>
<p>Définit les Fichiers de mappage du clavier Dans <em>/usr/share/keymaps</em> et <em>$FAI/files</em>. Vous ne Devez pas spécifier le chemin complet, puisque ce fichier sera localisé automatiquement.
</p>
</dd>
<dt class="hdlist1">
rootpw
</dt>
<dd>
<p>
Le mot de passe root chiffré pour le nouveau système. Vous pouvez utiliser <code>crypt(3)</code>, md5 et d' Autres types de hachage pour le mot de passe. Utilisez <code>mkpasswd(1)</code> pour créer le hachage d'un certain mot de passe. Par exemple, pour Générer le hachage MD5 pour l'utilisation du mot de passe.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ echo "yoursecrectpassword" | mkpasswd -Hmd5 -s</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
UTC
</dt>
<dd>
<p>
Réglez l'horloge du matériel à UTC si <em>UTC=yes</em>. Sinon, régler l'horloge à l'heure locale. Voir <code>clock(8)</code>pour en plus d'informations.
</p>
</dd>
<dt class="hdlist1">
TIMEZONE
</dt>
<dd>
<p>
Est-ce que le fichier d'initialisation par rapport à <em>/usr/share/zoneinfo/</em> indique votre fuseau horaire. Par exemple: <em>TIMEZONE=Europe/Berlin</em>.
</p>
</dd>
<dt class="hdlist1">
MODULESLIST
</dt>
<dd>
<p>Une liste des modules du Noyau qui sont chargés pendent Le démarrage du nouveau systême (Écrit dans /etc/modules).
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_diskconfig_a_hard_disk_configuration"><a id="diskconfig"></a>Configuration du disque dur</h3>
<div class="paragraph"><p>L'outil <code>setup-storage(8)</code> lit le fichier dans <em>$FAI/disk_config</em> pour la configuration du disque. Ce fichier décrit comment tous les disques Locaux devrons etre partitionné, Quels types de Systèmes de Fichiers doivent etre écris (Comme ext3/4, xfs, btrfs), et où ils seront Montés. Vous pouvez aussi créer des configurations RAID logiciel et LVM en Utilisant le Fichier de configuration. Il Est aussi possible de la mise en Conservation de le partitionnage du disque ou de conserver Les Donnees - sur CERTAINES partitions.</p></div>
<div class="paragraph"><p>Pendant le Processus d'installation de tous les Systèmes de Fichiers Locaux Sont Montés par rapport à <em>/target</em>. Par exemple, si vous Specifiez le Point de montage <em>/home</em> Dans un Fichier de configuration de disque, ce sera le répertoire <em>/target/home</em> pendant le Processus d'installation et deviendra <em>/home</em> pour le nouveau systéme Installé.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_extrbase_a_extract_base_file"><a id="extrbase"></a>Extraction du fichier de base</h3>
</div>
<div class="sect2">
<h3 id="_a_id_debconf_a_debconf_preseeding"><a id="debconf"></a>Debconf préconfiguration</h3>
</div>
<div class="sect2">
<h3 id="_a_id_repository_a_access_to_the_package_repository"><a id="repository"></a>L'Accès au dépôt de paquetages</h3>
</div>
<div class="sect2">
<h3 id="_a_id_packageconfig_a_software_package_configuration"><a id="packageconfig"></a>configuration du progiciel</h3>
<div class="paragraph"><p>Avant l'installation de de paquets, FAI va ajouter le contenu de Tous les Fichiers nommés <em>package_config/class.asc</em> à la liste des clés apt. Si votre depo locale est signé par votre keyid AB12CD34 vous pouvez Facilement ajouter cette clé, aussi FAI l'utilisera pendant l'installation. Utilisez cette commande pour Créer le fichier <em>CLASS.asc</em>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ gpg -a --export AB12CD34 &gt; /srv/fai/config/package_config/MYCLASS.asc</code></pre>
</div></div>
<div class="paragraph"><p>Le script <code>install_packages(8)</code> installe les Logiciels Sélectionnés. Il lira tous les fichiers de configuration Dans <em>$FAI/package_config</em> Dont le nom correspond aux classes definie. La syntaxe est tres simple. </p></div>
<div class="listingblock">
<div class="content">
<pre><code># an example package class

PACKAGES taskinst
german

PACKAGES aptitude
adduser netstd ae
less passwd

PACKAGES remove
gpm xdm

PACKAGES aptitude GRUB
lilo- grub</code></pre>
</div></div>
<div class="paragraph"><p>Commentaires Commencent par un Dièse et se terminent à la fin de la ligne. Chaqué commande de paquetage commence par Le mot <em>PACKAGES</em> Suivi par un nom de commande, Ce qui correspond à l'outil de package Comme apt-get, aptitude ou yum par exemple. la commande qui définit la commandent qui sera utilisé pour installer les paquets nommés après cette commande. La liste de toutes les commandes disponibles peuvent Être listé en utilisant <em>install_packages -H</em>. Les paquets d'outils pris en charges sont: <em>aptitude, apt-get, smart, yast, yum, rpm, zypper</em></p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
hold
</dt>
<dd>
<p>Mettez un paquet en attente. Ce Paquet ne sera pas pris en charges par dpkg, pas exemple non mis à niveau.
</p>
</dd>
<dt class="hdlist1">
install
</dt>
<dd>
<p>
Installez Tous les paquets (en utilisant <code>apt-get</code>) Qui sont précise dans les lignes Suivantes. Si un tiret est ajouté au nom du paquet (sans espace intermédiaire), le paquet sera supprimé, pas installé. Tous les noms de paquets sont vérifiées pour les fautes d'orthographe. Tout paquet qui n'existe pas, seront retiré de la liste des paquets à l'installation. Soyer donc prudentes de ne pas mal orthographier les noms de paquets.
</p>
</dd>
<dt class="hdlist1">
install-norec
</dt>
<dd>
<p>
Comme install,mais sans installer les paquets recommandés.
</p>
</dd>
<dt class="hdlist1">
remove
</dt>
<dd>
<p>
Supprimer tous les paquets qui sont péciser dans les lignes suivantes. Annexer un + au nom du paquet si le paquet doit Être installé.
</p>
</dd>
<dt class="hdlist1">
taskinst
</dt>
<dd>
<p>Installez tous les paquets appartenant aux tâches qui sont spécifiées dans les lignes suivantes à l'aide de <code>tasksel(1)</code>. Vous pouvez aussi utiliser <em>aptitude</em> pour installer les tâches.
</p>
</dd>
<dt class="hdlist1">
aptitude
</dt>
<dd>
<p>Installez Ttus les paquets avec la commande <code>aptitude</code>. Ce sera la Valeur par défaut à l'avenir et pourra remplacer apt-get et taskinst. Aptitudes peut aussi installer les paquets
</p>
</dd>
<dt class="hdlist1">
aptitude-r
</dt>
<dd>
<p>
Idem aptitude avec l'option <em>--with-recommends</em>.
</p>
</dd>
<dt class="hdlist1">
unpack
</dt>
<dd>
<p>Télécharge les paquets et décompresse seulement. Ne configure pas le paquet.
</p>
</dd>
<dt class="hdlist1">
dselect-upgrade
</dt>
<dd>
<p>Defini la sélections des paquets en Utilisant les lignes suivantes et installe ou supprime les paquets précisés. Ces lignes sont le résultat de la commande <em>dpkg --get-selections</em>. Il est recommandé de ne pas utiliser ce format, puisque vous devez aussi specifiez tous les paquets qui ne sont pas installés en raison d'une dépendance ou recommandation. Il vaut mieux juste spécifier le paquet que vous voulez avoir, et de laisser FAI (et apt-get) résoudre les dépendances.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Plusieurs lignes avec des listes de noms de paquets séparés par des espaces suivent les directive PACKAGES. Toutes les dépendances sont résolues. Les paquetages avec suffixe <em>-</em> (par exemple, <em>lilo-</em>) seront supprimés au lieu d'être installés. L'ordre des paquet n'a pas d'importance. Si vous souhaitez installer des paquets d'une autre version que la valeur par défaut, vous pouvez ajouter le nom de la version au nom du paquet comme dans <em>openoffice.org/etch-backports</em>. Vous pouvez également spécifier une certaine version comme <em>apt=0.3.1</em>. Plus d'informations sur ces fonctionnalités sont décrites dans <code>aptitude(8)</code>.</p></div>
<div class="paragraph"><p>Une ligne qui contient la commande <em>PRELOADRM</em>, télécharge un fichier à l'aide de <code>wget(1)</code> dans un répertoire avant d'installer les packages. À l'aide du <em>file:</em> URL, ce fichier est copié de <code>$FAI_ROOT</code> vers le répertoire de téléchargement. Par exemple, le package <code>realplayer</code> a besoin d'une archive pour installer le logiciel, donc cette archive est téléchargée dans le répertoire <em>/root</em>. Après l'installation des paquets, ce fichier sera supprimé. Si le fichier ne doit pas être supprimé, utilisez plutôt la commande <em>PRELOAD</em>.</p></div>
<div class="paragraph"><p>Il est possible d'ajouter une liste de noms de classes après la commande pour apt-get. Ainsi, cette commande <em>PACKAGE</em> ne sera exécutée que si la classe correspondante est définie. Ainsi, vous pouvez combiner de nombreux petits fichiers dans le fichier DEFAULT. ATTENTION! Utilisez cette fonctionnalité uniquement dans le fichier DEFAULT pour garder tout simple. Voir ce fichier pour quelques exemples.</p></div>
<div class="paragraph"><p>Si vous souhaitez supprimer un nom de paquet d'une certaine classe faisait partie avant de cette classe , vous ne devez pas supprimer le nom du paquet classe, mais plutôt de lui ajouter un tiret (-). Cela garantira que le paquet est enlevé pendant une mise a jour sur des hôtes qui étaient Installé en utilisant l'ancienne définition de classe qui comprenait ce nom de paquet.</p></div>
<div class="paragraph"><p>Si vous spécifiez un paquet qui n'existe pas, ce paquet sera supprimé automatiquement de la liste d'installation uniquement si la commande <em>install</em> est utilisée.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cscripts_a_customization_scripts"><a id="cscripts"></a> Scripts de personnalisation</h3>
<div class="paragraph"><p>La commande <code>fai-do-scripts(1)</code> est appelée pour exécuter tous les scripts dans ce répertoire. Si un répertoire avec un nom de classe existe, tous les scripts correspondant à <em>^[0-9][0-9]*</em> sont exécutés par ordre alphabétique. Il est donc possible d'utiliser des scripts de différentes langues (shell, cfengine, Perl, Python, Ruby, expect,..) pour une classe.</p></div>
<div class="paragraph"><p>Ces scripts écrivent leur sortie dans différents fichiers journaux, selon le type de script. Par exemple, Tous les scripts shell écrivent leur journal dans <code>shell.log</code>.</p></div>
<div class="sect3">
<h4 id="_a_id_shell_a_shell_scripts"><a id="shell"></a>Scripts shell </h4>
<div class="paragraph"><p>La plupart des scripts sont des scripts Bourne shell. Les scripts shell sont utiles si la tâche de configuration ne doit seulement appeler certaines commandes shell ou créer un fichier à partir de zéro. Afin de ne pas écrire beaucoup de scripts courts, il est possible d'utiliser la commande <code>ifclass</code> pour tester si certaines classes sont définies.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ifclass -o A B C</code></pre>
</div></div>
<div class="paragraph"><p>Vérifie si l'une des classes A, B ou C est définie. L'utilisation de -a (AND logique) vérifie si toutes les classes d'une liste sont définies. La commande <em>ifclass C</em> vérifie si seule la classe C est définie.</p></div>
<div class="paragraph"><p>Pour copier des fichiers avec des classes, utilisez la commande <code>fcopy(8)</code>. Si vous voulez extraire une archive à l'aide de classes, utilisez <code>ftar(8)</code>. Pour ajouter des lignes à un fichier de configuration, utilisez <code>ainsl(1)</code> au lieu de simplement <code>echo string &gt;&gt; filename</code>..</p></div>
<div class="paragraph"><p>FAI prend également en charge les scripts <em>zsh(1)</em> pendant la tâche de personnalisation. Dans les scripts, la variable <code>$classes</code> contient une liste séparée par des espaces avec les noms de toutes les classes définies.</p></div>
</div>
<div class="sect3">
<h4 id="_a_id_cfengine_a_cfengine_scripts"><a id="cfengine"></a>Scripts cfengine</h4>
<div class="paragraph"><p>CFEngine dispose d'un riche ensemble de fonctions pour modifier les fichiers de configuration existants, par exemple <em>LocateLineMatching, ReplaceAll, InsertLine,
AppendIfNoSuchLine, HashCommentLinesContaining</em>. Mais il ne peut pas traiter les variables qui sont indéfinies. Si une variable n'est pas définie, l'ensemble du script cfengine s'arrêtera.</p></div>
<div class="paragraph"><p>Plus d'informations peuvent être trouvées dans la page de manuel <code>cfengine(8)</code> ou sur la page d'accueil cfengine <a href="http://www.cfengine.org/">http://www.cfengine.org</a>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_a_id_hooks_a_hooks"><a id="hooks"></a>Hooks</h3>
<div class="paragraph"><p>Les Hooks vous permettent de spécifier des fonctions ou des programmes qui sont exécutés à certaines étapes du processus d'installation. Avant qu'une tâche soit appelée, FAI recherche les hooks existants pour cette tâche et les exécute. Comme on peut s'y attendre, les classes sont également utilisées lors de l'appel de hooks. Les hooks sont exécutés pour chaque classe définie. Vous n'avez qu'à créer le hook avec le nom de la classe désirée et il sera utilisé. Si plusieurs hooks pour une tâche existent, ils sont appelés dans l'ordre défini par les classes. Si <em>debug</em> est inclus dans <code>$FAI_FLAG</code> l'option <em>-d</em> est passée à tous les hooks, donc vous pouvez déboguer vos propres hooks. Si certaines tâches par défaut doivent être ignorées, utilisez la sous-routine <em>skiptask</em> et une liste de tâches par défaut comme paramètres. Dans les exemples fournis, les hooks de la classe CENTOS ignorent certaines tâches spécifiques de Debian.</p></div>
<div class="paragraph"><p>Le répertoire <em>$FAI/hooks/</em> contient tous les hooks. Un hook est un fichier exécutable qui suit le nom de tâche <em>taskname.CLASSNAME[.sh]</em> (par exemple, <em>repository.CENTOS</em> ou <em>savelog.LAST.sh), un nom de tâche et un nom de classe séparés par un point, éventuellement suivi de '.sh</em>. Le nom de la tâche spécifie la tâche devant précéder l'exécution de ce hook, si la classe spécifiée est définie pour le client d'installation. Voir la section <a href="#tasks">[tasks]</a> pour une liste complète des tâches par défaut pouvant être utilisées.</p></div>
<div class="paragraph"><p>Un hook du formulaire <em>hookprefix.classname</em> ne peut pas définir de variables pour le script d'installation, car il s'agit d'un sous-processus. Mais vous pouvez utiliser n'importe quel exécutable binaire ou n'importe quel script que vous avez écrit. Les hooks qui ont le suffixe <em>.sh</em> (par exemple, 'partition.DEFAULT.sh) doivent être des scripts Bourne shell et sont sourcé. Il est donc possible de redéfinir des variables pour les scripts d'installation.</p></div>
<div class="paragraph"><p>Dans la première partie de FAI, tous les hooks avec le préfixe <em>confdir</em> sont appelés. Ces hooks ne peuvent pas être localisés dans l'espace de configuration, car il n'est pas encore disponible. Par conséquent, ces hooks sont les seuls hooks situés dans <code>$nfsroot</code><em>/$FAI/hooks</em> sur le serveur d'installation. Tous les autres hooks se trouvent dans <em>$FAI_CONFIGDIR/hooks</em> sur le serveur d'installation.</p></div>
<div class="paragraph"><p>Tous les hooks appelés avant la définition des classes ne peuvent utiliser que les classes suivantes: <em>DEFAULT $HOSTNAME LAST</em>. Si un hook pour la classe <em>DEFAULT</em> doit être appelé uniquement si aucun hook pour la classe <code>$HOSTNAME</code> n'est disponible, insérez ces lignes sur le hook par défaut:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>hookexample.DEFAULT:

#! /bin/sh

# skip DEFAULT hook if a hook for $HOSTNAME exists
scriptname=$(basename $0 .DEFAULT)
[-f $FAI/hooks/$scriptname.$HOSTNAME ] &amp;&amp; exit
# here follows the actions for class DEFAULT
.
.</code></pre>
</div></div>
<div class="paragraph"><p>Quelques exemples de ce que les hooks pourraient être utilisés:</p></div>
<div class="ulist"><ul>
<li>
<p>Charger les modules du noyau avant que les classes soient définies dans <em>$FAI/class</em>.
</p>
</li>
<li>
<p>
     Envoyez un courriel à l'administrateur si l'installation est terminée.
</p>
</li>
<li>
<p>
     Installez un client sans disque et sautez le partitionnement de disque local.
</p>
</li>
<li>
<p>
     Jetez un oeil à <code>hooks/debconf.IMAGE</code> pour savoir comment cloner une machine en utilisant une image de système de fichiers.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_a_id_faiflags_a_fai_flags"><a id="faiflags"></a>FAI flags</h3>
<div class="paragraph"><p>La variable <code>$FAI_FLAGS</code> contient une liste de flags séparés par des espaces. Les flags suivants sont connus:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
verbose
</dt>
<dd>
<p>Créez une sortie verbeuse pendant l'installation. Cela doit toujours être le premier flag, de sorte que les définitions consécutives des flags seront affichées verbeusement.
</p>
</dd>
<dt class="hdlist1">
debug
</dt>
<dd>
<p>
Créer une sortie de débogage. Aucune installation sans assistance n'est effectuée. Pendant l'installation du paquet, vous devez répondre à toutes les questions des scripts postinstall sur la console du client. Beaucoup d'informations de débogage seront imprimées. Ce flag n'est utile que pour les développeurs FAI.
</p>
</dd>
<dt class="hdlist1">
sshd
</dt>
<dd>
<p>
Démarrez le démon ssh pour activer les connexions à distance. Vous pouvez ensuite vous connecter en tant que <em>root</em> à tous les clients d'installation pendant l'installation. Le mot de passe par défaut est <em>fai</em> et peut être modifié en définissant <code>FAI_ROOTPW</code> dans <code>nfsroot.conf(5)</code>. Pour vous connecter à partir de votre serveur vers le client d'installation (nommé demohost dans cet exemple), utilisez:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>$ ssh root@demohost
Warning: Permanently added 'demohost,192.168.33.100' to the list of known hosts.
root@demohost's password:</code></pre>
</div></div>
<div class="paragraph"><p>Ce n'est que le mot de passe root pendant le processus d'installation, pas pour le nouveau système installé. Vous pouvez également vous connecter sans mot de passe lorsque vous utilisez <code>$SSH_IDENTITY</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
createvt
</dt>
<dd>
<p>Créez deux terminaux virtuels et exécutez un bash si <em>ctrl-c</em> est tapé dans le terminal de console. Vous pouvez accéder aux terminaux supplémentaires en tapant <em>Alt-F2</em> ou <em>Alt-F3</em>. Sinon, aucun terminal n'est disponible et la saisie <em>ctrl-c</em> va redémarrer le client d'installation. La définition de ce flag est utile pour le débogage. Si vous voulez une installation qui ne devrait pas être interruptible, ne définissez pas ce flag.
</p>
</dd>
<dt class="hdlist1">
menu
</dt>
<dd>
<p>
Cela permet à un menu utilisateur de sélectionner un profil. Tous les fichiers <code>class/*.profile</code> sont lus et un menu basé sur des curses sera créé.
</p>
</dd>
<dt class="hdlist1">
reboot
</dt>
<dd>
<p>
Redémarrez le client d'installation une fois l'installation terminée sans taper RETURN sur la console. Si ce drapeau n'est pas défini, et que error.log contient quelque chose, le client d'installation s'arrêtera et attendra que vous appuyez sur RETURN. Si aucune erreur ne s'est produite, le client redémarre automatiquement automatiquement.
</p>
</dd>
<dt class="hdlist1">
halt
</dt>
<dd>
<p>
Arrêtez le client d'installation à la fin de l'installation, au lieu de redémarrer dans le nouveau système.
</p>
</dd>
<dt class="hdlist1">
initial
</dt>
<dd>
<p>
Utilisé par <code>setup-storage(8)</code>. Les partitions marquées avec <code>preserve_reinstall</code> sont préservées à moins que ce flag ne soit défini. Souvent, ce drapeau est placé dans un fichier<em>class/*.var</em> en utilisant le paramètre <em>flag_initial=1</em>.
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_install_a_fai_installs_your_plan"><a id="install"></a> FAI installe votre planification</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_early_part_of_an_installation">The early part of an installation</h3>
<div class="paragraph"><p>After the kernel has booted, it mounts the root file system via NFS
from the install server and starts the script
<em>/usr/sbin/fai</em> <span class="footnote" data-note="Since the root file system on the clients is mounted via
NFS, &lt;code&gt;fai&lt;/code&gt; is located in
&lt;em&gt;/srv/fai/nfsroot/usr/sbin&lt;/em&gt; on the install
server.">[<a id="_footnoteref_10" href="#_footnote_10" title="View footnote" class="footnote">10</a>]</span>. This script controls the sequence of the
installation. No other scripts in <em>/etc/init.d/</em> are used.</p></div>
<div class="paragraph"><p>The configuration space is made available via the configured method
(an NFS mount by default) from the install server to the path defined
in <em>$FAI</em> <span class="footnote" data-note="&lt;em&gt;$FAI&lt;/em&gt; is an internal variable used by the FAI
scripts. By default the path is &lt;em&gt;/var/lib/fai/config&lt;/em&gt;.">[<a id="_footnoteref_11" href="#_footnote_11" title="View footnote" class="footnote">11</a>]</span></p></div>
</div>
<div class="sect2">
<h3 id="_a_id_bootmesg_a_boot_messages"><a id="bootmesg"></a>Boot messages</h3>
<div class="paragraph"><p>When booting the install client from network card with PXE you will some
messages like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Managed PC Boot Agent (MBA) v4.00
Pre-boot eXecution Environment (PXE) v2.00
DHCP MAC ADDR: 00 A2 A3 04 05 06
DHCP.../

CLIENT MAC ADDR: 00 A2 A3 04 05 06  GUID: 3D6C4552
CLIENT IP: 192.168.33.100 MASK: 255.255.255.0  DHCP IP: 192.168.33.250
GATEWAY IP: 192.168.33.1

!PXE entry point found (we hope) at 9854:0106 via plan A
UNDI code segment at: 9854 len 5260
UNDI data segment at: 921D len 63A2
Getting cached packet  01 02 03
My Ip address seems to be C0A82164 192.168.33.100
ip=192.168.33.100:192.168.33.250:192.168.33.1:255.255.255.0
BOOTIF=01-00-A2-A3-04-05-06
SYSUUID=
TFTP prefix: fai/
Trying to load pxelinux.cfg/C0A82164

Loading vmlinuz-3.16.0-4-amd64..................
Loading initrd.img-3.16.0-4-amd64......................ready.</code></pre>
</div></div>
<div class="paragraph"><p>At this point the install client has successfully received the network
config via DHCP and the kernel and initrd via TFTP. It now boots the
Linux kernel and the initrd. If everything went right, the initrd
mounts the nfsroot <span class="footnote" data-note="&lt;em&gt;/srv/fai/nfsroot&lt;/em&gt; from the install
server via NFS">[<a id="_footnoteref_12" href="#_footnote_12" title="View footnote" class="footnote">12</a>]</span> and the FAI scripts are started. The first
thing you see is the red FAI copyright message.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>             -------------------------------------------------
                   Fully Automatic Installation  -  FAI

                   5.3.3~bpo8+2  (c) 1999-2017
               Thomas Lange  &lt;lange@informatik.uni-koeln.de&gt;
             -------------------------------------------------

Calling task_confdir
Kernel currently running: Linux 3.16.0-4-amd64 x86_64 GNU/Linux
Kernel parameters: BOOT_IMAGE=vmlinuz-3.16.0-4-amd64 initrd=initrd.img-3.16.0-4-amd64 \
 rw aufs ip=dhcp root=192.168.33.250:/srv/fai/nfsroot FAI_FLAGS=verbose,sshd,createvt\
 FAI_CONFIG_SRC=nfs://faiserver/srv/fai/cskoeln FAI_ACTION=install quiet\
 BOOTIF=01-00-a2-a3-04-05-06
Reading /tmp/fai/boot.log
FAI_FLAGS: verbose sshd createvt
Setting SERVER=faiserver. Value extracted from FAI_CONFIG_SRC.
FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config
Calling task_setup
FAI_FLAGS: verbose sshd createvt
15 Jan 13:22:37 ntpdate[1533]: step time server 192.168.33.250 offset -0.342793 sec
Press ctrl-c to interrupt FAI and to get a shell
Starting FAI execution - 20170115_132237
Calling task_defclass
fai-class: Defining classes.
Executing /var/lib/fai/config/class/10-base-classes.
10-base-classes      OK.
Executing /var/lib/fai/config/class/20-hwdetect.source.
Loading kernel module md-mod
20-hwdetect.source   OK.
Executing /var/lib/fai/config/class/50-host-classes.
50-host-classes      OK.
List of all classes: DEFAULT LINUX AMD64 FAIBASE DHCPC DEMO GRUB client01 LAST</code></pre>
</div></div>
<div class="paragraph"><p>You can also see the list of FAI classes, that are defined for this
host. This list is very important for the rest of the installation.</p></div>
<div class="paragraph"><p>The first task is called <em>confdir</em>, which is responsible for getting
access to the config space. Here, we use an NFS mount from the install
server as you can see on the console (and later in the logs).</p></div>
<div class="listingblock">
<div class="content">
<pre><code>FAI_CONFIG_SRC is set to nfs://faiserver/srv/fai/config
Configuration space faiserver:/srv/fai/config mounted to /var/lib/fai/config</code></pre>
</div></div>
<div class="paragraph"><p>Before the installation is started (<code>$FAI_ACTION=install</code>) the computer
beeps three times. So, be careful when you hear three beeps but you do
not want to perform an installation and let FAI erase all yout data on
the local disk!</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_reboot_a_rebooting_the_computer_into_the_new_system"><a id="reboot"></a>Rebooting the computer into the new system</h3>
<div class="paragraph"><p>For rebooting the computer during or at the end of the installation you
should use the command <code>faireboot</code> in favour of the normal reboot command.
Use <code>faireboot</code> also if logged in from remote. If the installation
hasn’t finished, use <em>faireboot -s</em>, so the log files are also copied
to the install server.</p></div>
<div class="paragraph"><p>If the installation has finished successfully, the computer should boot a
small Debian system. You can login as user <em>demo</em> or <em>root</em> with password <em>fai</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_isetup_a_starting_fai_task_confdir"><a id="isetup"></a>Starting FAI (task confdir)</h3>
<div class="paragraph"><p>After the install client has booted only the script <em>/usr/sbin/fai</em> is
executed. It will do some minimal initialization. The variable
<code>$FAI_CONFIG_SRC</code> <span class="footnote" data-note="It it defined on the kernel command line">[<a id="_footnoteref_13" href="#_footnote_13" title="View footnote" class="footnote">13</a>]</span>
is used to get access to the FAI configuration space which is then
available in the directory <code>$FAI</code> <span class="footnote" data-note="/var/lib/fai/config">[<a id="_footnoteref_14" href="#_footnote_14" title="View footnote" class="footnote">14</a>]</span>. FAI
will not proceed without the config space.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_iclass_a_defining_classes_and_variables_tasks_defclass_and_defvar"><a id="iclass"></a>Defining classes and variables (tasks defclass and defvar)</h3>
<div class="paragraph"><p>The command <code>fai-class(1)</code> executes scripts in <em>$FAI/class</em> for defining
classes. If the scripts write a string to stdout, this will be defined
as a class. Read all the details in the man page of <code>fai-class(1)</code>.</p></div>
<div class="paragraph"><p>After defining the classes, every file matching <em>.var</em> with a prefix
which matches a defined class is sourced to define variables. It must
contain vaild shell code.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipartition_a_partitioning_local_disks_creating_file_systems_task_partition"><a id="ipartition"></a>Partitioning local disks, creating file systems (task partition)</h3>
<div class="paragraph"><p>For the disk partitioning exactly one disk configuration file from
<em>$FAI/disk_config</em> is selected using classes.</p></div>
<div class="paragraph"><p>The format of the disk configuration is similar to a fstab file.</p></div>
<div class="paragraph"><p>The partitioning tool <code>setup-storage(8)</code> performs all commands
necessary for creating the disk partition layout, software RAID, LVM
and for creating the file systems. Read the manual page of
<code>setup-storage(8)</code> for a detailed description and some examples of the
format.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipreseed_a_debconf_preseeding_task_debconf"><a id="ipreseed"></a>Debconf preseeding (task debconf)</h3>
<div class="paragraph"><p>Files in <em>$FAI/debconf</em> are used for the usual <code>debconf(7)</code> presseding
if the file names match a class name.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ipackages_a_installing_software_packages_task_instsoft"><a id="ipackages"></a>Installing software packages (task instsoft)</h3>
<div class="paragraph"><p>The command <code>install_packages(8)</code> reads the config files from
<em>$FAI/package_config</em> in a class based manner and installs software
packages on the new file system.</p></div>
<div class="paragraph"><p>It installs the packages using <code>apt-get(8)</code>, <code>aptitude(1)</code>, <code>yum</code> or other
package tools without any manual interaction needed. Package
dependecies are also resolved by the package tools.</p></div>
<div class="paragraph"><p>The format of the configuration files is described in <a href="#packageconfig">[packageconfig]</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_icscripts_a_site_specific_customization_task_configure"><a id="icscripts"></a>Site specific customization (task configure)</h3>
<div class="paragraph"><p>Often the default configurations of the software packages will not
meet your site-specific needs. You can call arbitrary scripts which
adjust the system configuration. Therefore the command
<code>fai-do-scripts(1)</code> executes scripts in <em>$FAI/scripts</em> in a class
based manner. It is possible to have several scripts of different
types (shell, cfengine, …) to be executed for one class.</p></div>
<div class="paragraph"><p>The default set of scripts in <em>$FAI/scripts</em> include examples for
installing Debian and CentOS machines. They set the root password, add
a demo user account, set the timezone, configure the network for DHCP
or using a fixed IP address, setup grub and more.
They should do a reasonable job for your installation. You can edit
them or add new scripts to match your local needs.</p></div>
<div class="paragraph"><p>More information about these scripts are described in <a href="#cscripts">[cscripts]</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_isavelog_a_saving_log_files_task_savelog"><a id="isavelog"></a>Saving log files (task savelog)</h3>
<div class="paragraph"><p>When all tasks are finished, the log files are written to
<em>/var/log/fai/$HOSTNAME/install/</em>
<span class="footnote" data-note="&lt;em&gt;/var/log/fai/localhost/install/&lt;/em&gt; is a link to this
directory.">[<a id="_footnoteref_15" href="#_footnote_15" title="View footnote" class="footnote">15</a>]</span> on the new system and to the account on the install server
if <code>$LOGUSER</code> is defined. It is also possible to specify
another host as log saving destination through the variable
<code>$LOGSERVER</code>. If <code>$LOGSERVER</code> is not defined, FAI uses the variable
<code>$SERVER</code> which is only defined during an initial installation (by
get-boot-info). Make sure to set <code>$LOGSERVER</code> in a <em>class/*.var</em> script
if you are using the action <em>softupdate</em>.</p></div>
<div class="paragraph"><p>Additionally, two symlinks will be created to indicated the last
directory written to. The symlink <em>last</em> points to the log directory
of the last FAI action performed. The symlinks <em>last-install</em> and
<em>last-sysinfo</em> point to the directory with of the last corresponding
action. By default log files will be copied to the log
server using scp. You can use the variable <code>$FAI_LOGPROTO</code> in file
<em>fai.conf(5)</em> to choose another method for saving logs to the remote
server. Here’s an example of the symlink structure:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>lrwxrwxrwx   1 fai fai   23 Dec  2  2013 last-sysinfo -&gt; sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Dec  2  2013 sysinfo-20131202_161237
drwxr-xr-x   2 fai fai 4096 Feb 14  2014 install-20140214_142150
drwxr-xr-x   2 fai fai 4096 Dec  2 11:47 install-20141202_113918
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last-install -&gt; install-20141204_131351
lrwxrwxrwx   1 fai fai   23 Dec  4 13:22 last -&gt; install-20141204_131351
drwxr-xr-x   2 fai fai 4096 Dec  4 13:22 install-20141204_131351</code></pre>
</div></div>
<div class="paragraph"><p>Examples of the log files can be found at <a href="http://fai-project.org/logs">http://fai-project.org/logs</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_ireboot_a_reboot_the_new_installed_system"><a id="ireboot"></a>Reboot the new installed system</h3>
<div class="paragraph"><p>Before rebooting, the install client calls <code>fai-chboot -d &lt;hostname&gt;</code>
on the install server, to disable its own PXELINUX
configuration. Otherwise, it would restart the installation during the
next boot. Normally this should boot the new installed system from
its second boot device, the local hard disk.</p></div>
<div class="paragraph"><p>At the end, the system is automatically rebooted if "reboot" was added to
<code>$FAI_FLAGS</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_advanced_a_advanced_fai_topics"><a id="advanced"></a>Advanced FAI topics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_checkbootp_a_checking_parameters_received_from_dhcp_servers"><a id="checkbootp"></a>Checking parameters received from DHCP servers</h3>
<div class="paragraph"><p>If the install client boots you can check
if all information from the DHCP daemon are received
correctly. The received information is written to
<em>/tmp/fai/boot.log</em>. An example of the result of a DHCP request can be
found in the sample log files.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_fai_monitor_a_monitoring_multiple_client_installations"><a id="fai-monitor"></a>Monitoring multiple client installations</h3>
<div class="paragraph"><p>You can monitor the installation of all install clients with the
command <code>fai-monitor(8)</code>. All clients check if this daemon is running
on the install server (or the machine defined by the variable
<code>$monserver</code>). Each time a task starts or ends, a message is sent. The
FAI monitor daemon prints this messages to standard output. There’s
also a graphical frontend available, called <code>fai-monitor-gui(1)</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$  fai-monitor | fai-monitor-gui - &amp;</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_mac_a_collecting_ethernet_addresses_for_multiple_hosts"><a id="mac"></a>Collecting Ethernet addresses for multiple hosts</h3>
<div class="paragraph"><p>You have to collect all Ethernet (MAC) addresses of the install
clients and assign a host name and IP address to each client. To
collect the MAC addresses, boot your install clients.
You can already do this before any DHCP daemon is running in your
subnet. They will fail to boot (because of the missing DHCP or missing TFTP),
but you can still collect the MAC addresses.</p></div>
<div class="paragraph"><p>While the install clients are booting, they send broadcast packets to the
LAN. You can log the MAC addresses of these hosts by running the
following command simultaneously on the server:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# tcpdump -qtel broadcast and port bootpc &gt;/tmp/mac.list</code></pre>
</div></div>
<div class="paragraph"><p>After the hosts have been sent some broadcast packets abort <code>tcpdump</code>
by typing <em>ctrl-c</em>. You get a list of all
unique MAC addresses with these commands:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ perl -ane 'print "\U$F[0]\n"' /tmp/mac.list|sort|uniq</code></pre>
</div></div>
<div class="paragraph"><p>After that, you only have to assign these MAC addresses to host names
and IP addresses (<em>/etc/ethers</em> and <em>/etc/hosts</em> or corresponding NIS
maps). With this information you can configure your <code>DHCP</code>
daemon (see the section <a href="#bootdhcp">[bootdhcp]</a>). <span class="footnote" data-note="I recommend to write the MAC
addresses (last three bytes will suffice if you have network cards
from the same vendor) and the host name in the front of each chassis.">[<a id="_footnoteref_16" href="#_footnote_16" title="View footnote" class="footnote">16</a>]</span></p></div>
<div class="sect3">
<h4 id="_debugging_the_network_traffic">Debugging the network traffic</h4>
<div class="paragraph"><p>If the client can’t successfully boot from the network card, use
<code>tcpdump(8)</code> to look for Ethernet packets between the install server
and the client. Search also for entries in several log files made by
<code>tftpd(8)</code> and <code>dhcpd(8)</code> :</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver$ egrep "tftpd|dhcpd" /var/log/*</code></pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_a_id_pxeboot_a_details_of_pxe_booting"><a id="pxeboot"></a>Details of PXE booting</h3>
<div class="paragraph"><p>Here we describe the details of PXE booting, which are only needed if
you have problems when booting your install clients.</p></div>
<div class="paragraph"><p>Almost all modern bootable network cards support the PXE boot environment.
PXE is the Preboot Execution Environment.
This requires the PXELINUX bootloader and a special version of the <em>TFTP</em>
daemon, which is available in the Debian packages <code>pxelinux</code> and
<code>tftpd-hpa</code>. PXE booting also needs a DHCP server, so that the network
card can configure its IP parameters. This is the sequence of a PXE boot:</p></div>
<div class="ulist"><ul>
<li>
<p>
Network card of the client sends its MAC address
</p>
</li>
<li>
<p>
DHCP server replies with IP configuration for the client
</p>
</li>
<li>
<p>
Network card configures IP
</p>
</li>
<li>
<p>
Install client gets the pxelinux.0 binary via TFTP
</p>
</li>
<li>
<p>
Get the pxelinux.cfg/C0A8210C configuration file via TFTP
</p>
</li>
<li>
<p>
C0A8210C is the IP address of the client in hexadecimal
</p>
</li>
<li>
<p>
This configuration contains kernel, initrd and additional kernel
command line parameters, which was created by <code>fai-chboot</code>.
</p>
</li>
<li>
<p>
Get the kernel and initrd via TFTP.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Example of a pxelinux.cfg file:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>default fai-generated

label fai-generated
kernel vmlinuz-3.16.0-4-amd64
append initrd=initrd.img-3.16.0-4-amd64 ip=dhcp  root=/srv/fai/nfsroot aufs  FAI_FLAGS=verbose,sshd,createvt FAI_CONFIG_SRC=nfs://faiserver/srv/fai/config FAI_ACTION=install</code></pre>
</div></div>
<div class="paragraph"><p>See <em>/usr/share/doc/syslinux/pxelinux.doc</em> for more detailed
information about PXELINUX. There’s a new lpxelinux binary which also
support loading the kernel and initrd via FTP or HTTP. The command
<em>fai-chboot(8)</em> supports this with the option <em>-U</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_customizing_your_install_server_setup_a_customizing_your_install_server_setup"><a id="Customizing your install server setup"></a>Customizing your install server setup</h3>
<div class="ulist"><ul>
<li>
<p>
local/faster package mirror
</p>
</li>
<li>
<p>
different loguser
</p>
</li>
<li>
<p>
local root pw inside nfsroot
</p>
</li>
</ul></div>
<div class="paragraph"><p>The configuration for the FAI package (not the configuration data for
the install clients) is defined in <em>fai.conf(5)</em>. Definitions that are
only used for creating the nfsroot are located in
<em>nfsroot.conf(5)</em>. Check these important variables in <em>nfsroot.conf</em>
before calling <em>fai-setup</em> or <em>fai-make-nfsroot</em>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_DEBOOTSTRAP
</dt>
<dd>
<p>
Building the nfsroot uses the command debootstrap(8)`. It needs the location of a Debian mirror and the
name of the distribution (wheezy, jessie, stretch, sid) for which the basic Debian
system should be built. Do not use different distributions here and in
<em>/etc/fai/apt/sources.list</em>. This will create a broken nfsroot.
</p>
</dd>
<dt class="hdlist1">
NFSROOT_ETC_HOSTS
</dt>
<dd>
<p>
This variable is only needed if the clients do not have access to a DNS server.
This multiline variable is added to /etc/hosts inside the
nfsroot. Then the install clients can access those hosts by name
without using DNS.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The content of <em>/etc/fai/apt/sources.list</em> is
used by the install server and also by the clients. If your install
server has multiple network cards and different host names for each
card (as for a Beowulf server), use the install server name which is
known by the install clients.</p></div>
<div class="paragraph"><p>If you have problems running <code>fai-setup</code>, they usually stem from
<code>fai-make-nfsroot(8)</code> which is called by former command. Adding <em>-v</em>
gives you a more verbose output which helps you pinpoint the
error. The output is written to
<em>/var/log/fai/fai-make-nfsroot.log</em>. <span class="footnote" data-note="For debugging purpose
it may help to enter the chroot environment manually using this
command.  &lt;em&gt;faiserver# chroot /srv/fai/nfsroot bash&lt;/em&gt;">[<a id="_footnoteref_17" href="#_footnote_17" title="View footnote" class="footnote">17</a>]</span></p></div>
<div class="paragraph"><p>The setup also creates the account <em>fai</em> (defined by <code>$LOGUSER</code>) if
not already available. So you can add a user before calling
<code>fai-setup(8)</code> using the command <code>adduser(8)</code> and use this as your
local account for saving log files. The log files of all install
clients are saved to the home directory of this account. You should
change the primary group of this
account, so this account has write permissions to <em>/srv/tftp/fai</em> in
order to call fai-chboot for creating the PXE configuration for the hosts.</p></div>
<div class="paragraph"><p>When you make changes to <em>fai.conf</em>, <em>nfsroot.conf</em> the
nfsroot has to be rebuilt by calling <code>fai-make-nfsroot(8)</code>. If you
only like to install a new kernel package to the nfsroot add the flags <em>-k</em> or
<em>-K</em> to <code>fai-make-nfsroot</code>. This will not recreate your nfsroot, but
only updates your kernel and kernel modules inside the nfsroot or add
additional packages into the nfsroot.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_cdboot_a_creating_a_fai_cd_or_and_usb_stick"><a id="cdboot"></a>Creating a FAI CD or and USB stick</h3>
<div class="paragraph"><p>You can easily create an installation CD (or USB stick) of your
network installation setup. This will perform the same installation
and configuration from CD without the need of the install server.
Therefore you need to create a partitial mirror of all Debian packages
needed for your FAI classes (using <code>fai-mirror(1)</code>). Then the command
<code>fai-cd(8)</code> will put this mirror, the nfsroot and the config space
onto a bootable CD. That’s it!</p></div>
<div class="paragraph"><p>This installation CD contains all data needed for the
installation. The command <code>fai-cd(8)</code> puts the nfsroot, the
configuration space and a subset of the Debian mirror onto a
CD-ROM. A partial package mirror is created using the command
<code>fai-mirror(1)</code> which contains all packages that are used by the
classes used in your configuration space.  A sample ISO image is
available at <a href="http://fai-project.org/fai-cd">http://fai-project.org/fai-cd</a>.</p></div>
<div class="paragraph"><p>Using the command <code>dd(1)</code> you can also create a bootable USB
stick by just writing the content of the ISO file to your USB stick
(here the stick is <em>/dev/sdf</em>).</p></div>
<div class="listingblock">
<div class="content">
<pre><code> faiserver# dd if=fai-cd.iso of=/dev/sdf bs=1M</code></pre>
</div></div>
<div class="paragraph"><p>This is no live CD of the install server.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_diskimage_a_creating_vm_disk_images_using_fai"><a id="diskimage"></a>Creating VM disk images using FAI</h3>
<div class="paragraph"><p>Using the command <code>fai-diskimage(8)</code> you can create Linux machine disk
images, which can be used with a virtual machine like KVM, VMware,
VirtualBox or a cloud service like OpenStack, GCE, EC2 and others. The
installation process performs the normal FAI tasks on a raw disk
image. After the installation you can boot the disk image and have a
running system. The disk image can also be converted to qcow2 format.</p></div>
<div class="listingblock">
<div class="content">
<pre><code> faiserver# export FAI_BASEFILEURL=http://fai-project.org/download/basefiles/
 faiserver# fai-diskimage -u cloud3 -S 2G -cDEBIAN,JESSIE64,AMD64,FAIBASE,GRUB_PC,CLOUD,GCE disk.raw</code></pre>
</div></div>
<div class="paragraph"><p>Creates the file disk.raw for a host called cloud3, with a small set
of software packages.</p></div>
<div class="listingblock">
<div class="content">
<pre><code> # export FAI_BASEFILEURL=http://fai-project.org/download/basefiles/
 # cl=DEFAULT,DHCPC,DEBIAN,AMD64,FAIBASE,GRUB_PC,UBUNTU,XENIAL,XENIAL64,XORG
 # fai-diskimage -v -u foobar -S5G -c$cl ubuntu.qcow2</code></pre>
</div></div>
<div class="paragraph"><p>Creates a disk image called ubuntu.qcow2 for a Ubuntu 16.04 desktop
with hostname set to foobar.</p></div>
<div class="paragraph"><p>You do not neet to setup the nfsroot when only using
fai-diskimage. But you need a basefile in your configuration
space. You can download a Debian base image from
<a href="http://fai-project.org/download/basefile">http://fai-project.org/download/basefile</a> and copy this into your
config space. If you already have set up the nfsroot you can copy the
Debian basefile from the nfsroot into your config space by using this
command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> $ cp /srv/fai/nfsroot/var/tmp/base.tar.xz
 $ /srv/fai/config/basefiles/JESSIE64.tar.xz</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_sysinfo_a_fai_rescue_system"><a id="sysinfo"></a>FAI rescue system</h3>
<div class="paragraph"><p>If you set the variable <code>$FAI_ACTION</code> to <em>sysinfo</em> (for e.g. by using
<code>fai-chboot -S</code>), the client will not install a new system, but will
collect a lot of system information.
If you set <code>$FAI_ACTION</code> to <em>inventory</em> you will only get a few
hardware information.
Both actions can be used for FAI as a rescue system.</p></div>
<div class="paragraph"><p>Type <em>ctrl-c</em> to get a shell or use <em>Alt-F2</em> or <em>Alt-F3</em> and you will get
another console terminal, if you have added <em>createvt</em> to <code>$FAI_FLAGS</code>.</p></div>
<div class="paragraph"><p>You now have a running Linux system on the install client without
using the local hard disk. Use this as a rescue system if your local
disk is damaged or the computer can’t boot properly from hard
disk. You will get a shell and you can execute various commands
(<code>dmesg</code>, <code>lsmod</code>, <code>df</code>, <code>lspci</code>, …). Look at the log file in
<em>/tmp/fai</em>. There you can find much information about the boot
process.</p></div>
<div class="paragraph"><p>FAI mounts all file systems it finds on the local disks read only. It
also tells you on which partition a file <em>/etc/fstab</em> exists. When
only one file system table is found, the partitions are mounted
according to this information. Here’s an example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>demohost:~# df
Filesystem      1K-blocks      Used Available Use% Mounted on
rootfs            4099064    414088   3645296  11% /
192.168.33.250:/srv/fai/nfsroot
                  3905600    410976   3454944  11% /live/image
tmpfs              193464      3112    190352   2% /live/cow
aufs              4099064    414088   3645296  11% /

192.168.33.250:/srv/fai/config
                  3905600    410976   3454944  11% /var/lib/fai/config
/dev/sda1          241116     74519    154149  33% /target
/dev/sda9         4364212    139888   4179988   4% /target/home
/dev/sda7          553376     16840    536536   4% /target/tmp
/dev/sda8         2221628    275936   1832840  14% /target/usr
/dev/sda6          577096    172924    374856  32% /target/var</code></pre>
</div></div>
<div class="paragraph"><p><strong>This method can be used as a rescue environment!</strong> If you need a file
system with read-write access use the <code>rwmount</code> command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>demohost# rwmount /target/home</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_id_nonfs_a_fai_without_nfs"><a id="nonfs"></a>FAI without NFS</h3>
<div class="paragraph"><p>To boot into FAI and begin the installation sequence
without using the NFS protocol. You boot the client machine using PXE as
usual and then retrieve an image containing the nfsroot via http.</p></div>
<div class="paragraph"><p>To create an image, use fai-cd’s -S argument</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-cd -S squash.img</code></pre>
</div></div>
<div class="paragraph"><p>Move this image to a directory from which it can be requested via http
(usually a directory served by the webserver)</p></div>
<div class="paragraph"><p>To now request the squashfs image, add the following to your kernel
command line, e.g. in your pxelinux configuration file for the client.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>root=live:http://faiserver/cskoeln/squash.img</code></pre>
</div></div>
<div class="paragraph"><p>Replace faiserver with the domain name or IP of the machine your
squash image is served from.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_otherdists_a_installing_other_distributions_using_a_debian_nfsroot"><a id="otherdists"></a>Installing other distributions using a Debian nfsroot</h3>
<div class="paragraph"><p>You can install all sorts of Linux distributions from a single Debian
nfsroot. Therefore you have to create a base.tar.xz of the distribution
you like to install and place it info the <code>basefiles</code> directory. Then
name it UBUNTU1404.tar.xz for example. An install client which belongs
to the class UBUNTU1404 then extracts this base file into its empty
file system. Additionally you have to adjust the <em>sources.list</em> or
similar configuration files which are needed for specifying the
location of the package repository.</p></div>
<div class="paragraph"><p>The tool <code>rinse(8)</code> is used for creating base files for distribution
like CentOS, openSUSE, Scientific Linux Cern or Fedora.
Some basefiles can be downloaded from
<a href="http://fai-project.org/download/basefiles/">http://fai-project.org/download/basefiles/</a>.</p></div>
<div class="paragraph"><p>The script <code>mk-basefile</code> in
<em>/usr/share/doc/fai-doc/examples/simple/basefiles/</em> helps creating
this base files.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_dirinstall_a_creating_chroot_and_virtualization_environments"><a id="dirinstall"></a>Creating chroot and virtualization environments</h3>
<div class="paragraph"><p>If you have to create some chroot environments, or a virtualization
environment where you neither can nor want to run a normal Debian
Installer in to get to a working system (for example, Xen guest
domains), there is the FAI action <em>dirinstall</em>.
By calling</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai &lt;options&gt; dirinstall &lt;target-directory&gt;</code></pre>
</div></div>
<div class="paragraph"><p>and using either the option <em>-c &lt;classes&gt;</em> or <em>-N</em> you get a FAI
installation, without the partitioning action, right into the target
directory. The host name for the target installation can be specified
using <em>-u &lt;host-name&gt;</em></p></div>
<div class="paragraph"><p>This, for example, can be used to combine FAI with the tool
<em>xen-tools</em>, which helps you to build Xen guest domains. <em>xen-tools</em>
are very nice for generating configuration files and block devices for
new guests based on simple commands and/or configuration files, but
they can only assign one role per installation for customization.
FAI-users need and want more, as they are used to have the class
system.  They get them even in xen-tools installations, by using the
following code as a xen-tools role script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>#!/bin/sh
TARGET=$1
CMD="fai -N  -v -u ${hostname} dirinstall $TARGET"
echo running $CMD
$CMD</code></pre>
</div></div>
<div class="paragraph"><p>Then, you will want to set the variable <em>install=0</em> the xen-tools
config for that host.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_softupdate_a_using_fai_for_updates"><a id="softupdate"></a>Using FAI for updates</h3>
<div class="paragraph"><p>FAI can also do updates of already running systems, without a
re-installation from scratch.
This is called softupdate. A FAI softupdate skips the tasks which are
not suitable for updating a running system, like partitioning the
hard disks and creating file systems. Instead, it only executes the
tasks for updating and installing software packages and calling the
customization scripts.</p></div>
<div class="paragraph"><p>To run a softupdate call:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># fai -v -s nfs://faiserver/srv/fai/config softupdate</code></pre>
</div></div>
<div class="paragraph"><p>By default, a softupdate uses the list of classes defined during the
initial installation. Make sure to set the variable <code>$LOGSERVER</code> (done
in a <em>class/*.var</em> file) if FAI should save the log files to a remote
machine.</p></div>
<div class="paragraph"><p>It’s up to you, how to start a softupdate on a bigger number of hosts.
You may do the softupdate on a regular basis via cron or you can use tools
like <code>clusterssh(1)</code> to start a softupdate via a push on a list of
hosts.</p></div>
<div class="paragraph"><p>Keep in mind, that the customization scripts are run every time you do
a softupdate. That means, they have to be <strong>idempotent</strong> i.e. the result
of their operation should always produce the same result, even when
they run more than once.</p></div>
<div class="paragraph"><p>For example appending a line to a file must not done via this code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ echo "some strings" &gt;&gt; /etc/fstab</code></pre>
</div></div>
<div class="paragraph"><p>Instead use the command <code>ainsl(1)</code> in a shell script or use cfengine’s
function <em>AppendIfNoSuchLine</em>.</p></div>
<div class="paragraph"><p>All commands in the customization script must be capable of modifying
the target file system wether it’s available in <em>/target</em> during the
initial installation or wether it’s the normal file system relative to
<em>/</em> during softupdate.</p></div>
<div class="paragraph"><p>Here are some variable that help writing these scripts:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>$target</code>
</dt>
<dd>
<p>
Points to the root directory of the client, which
is_/target_ during installation and <em>/</em> during a softupdate.
</p>
</dd>
<dt class="hdlist1">
<code>$FAI_ROOT</code>
</dt>
<dd>
<p>
It’s the same value as <code>$target</code>. For historic reasons
we have both these variables in FAI.
</p>
</dd>
<dt class="hdlist1">
<code>$ROOTCMD</code>
</dt>
<dd>
<p>
In case of the installation this is an alias for <em>chroot $target</em> in case of
softupdate it’s just empty. You can prepend this to commands if you need to run a
command inside the clients target file system via chroot.
</p>
</dd>
<dt class="hdlist1">
<code>$FAI_ACTION</code>
</dt>
<dd>
<p>
If you need to call code depending on the FAI action performed, you
can use this variable. It contains the currently executed action:
<em>install</em>, <em>softupdate</em>, <em>dirinstall</em>, <em>sysinfo</em>, <em>inventory</em> or your
own defined action.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_archcross_a_how_to_install_32bit_os_from_a_64bit_os"><a id="archcross"></a>How to install 32bit OS from a 64bit OS</h3>
<div class="paragraph"><p>To install a computer with a 32bit OS, you need an i386 nfsroot.
Creating this 32bit nfsroot on an install server running amd64 is
quite simple. Install and set up the FAI packages. Then copy your FAI
config files to a new subdirectory.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# cp -a /etc/fai /etc/fai-i386</code></pre>
</div></div>
<div class="paragraph"><p>Edit the variable <code>$FAI_DEBOOTSTRAP_OPTS</code> in
<em>/etc/fai-i386/nfsroot.conf</em> and add the option <code>--arch
i386</code>. Also choose a different directory for your new nfsroot. Here
are the two lines after editing.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NFSROOT=/srv/fai/nfsroot-i386
FAI_DEBOOTSTRAP_OPTS="--arch i386 --exclude=info --include=aptitude""</code></pre>
</div></div>
<div class="paragraph"><p>Now call fai-make-nfsroot which creates the 32bit nfsroot in
<em>/srv/fai/nfsroot-i386</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-make-nfsroot -v -C/etc/fai-i386</code></pre>
</div></div>
<div class="paragraph"><p>Creating a partitial mirror using <code>fai-mirror(1)</code> that is needed for
a bootable CD or USB stick is also possible on a different architecture.
You have to specify the architecture when calling fai-mirror.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fai-mirror -m800 -B -a i386 -v -cDEFAULT,DEBIAN,FAIBASE,I386 /srv/mirror-i386</code></pre>
</div></div>
<div class="paragraph"><p>That’s all!</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_hints_a_various_hints_and_details"><a id="hints"></a>Various hints and details</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_tasks_a_the_list_of_tasks"><a id="tasks"></a>The list of tasks</h3>
<div class="paragraph"><p>Most tasks of the installation are defined as subroutines which are
defined in <em>/usr/lib/fai/subroutines</em> (e.g. <code>task_instsoft</code>).
Some are external shell scripts located in <em>/usr/lib/fai/</em>.
They are called via a superior subroutine called <em>task</em>.
This subroutine calls hooks if available and then calls the task (defined as
<em>task_&lt;name&gt;</em>). A task and its hooks can be
skipped on demand by using the command <em>skiptask()</em>.</p></div>
<div class="paragraph"><p>Now follows the description of all tasks, listed in the order
they are executed.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
confdir
</dt>
<dd>
<p>
The kernel appended parameters may define variables, the syslog daemon is
started. The list of network devices is stored in
<code>$netdevices</code>. Then additional parameters are fetched from a DHCP
server. The DNS resolver configuration file is created.
</p>
<div class="paragraph"><p>The location of the configuration space is defined by the variable
<code>$FAI_CONFIG_SRC</code>.</p></div>
<div class="paragraph"><p>After that, the file <em>$FAI/hooks/subroutines</em> is sourced if it
exists. Using this file, you can define your own subroutines or
override the definition of FAI’s subroutines.</p></div>
</dd>
<dt class="hdlist1">
setup
</dt>
<dd>
<p>
This task sets the system time, all <code>$FAI_FLAGS</code> are defined and two
additional virtual terminals are opened on demand. A secure shell
daemon is started on demand for remote logins.
</p>
</dd>
<dt class="hdlist1">
defclass
</dt>
<dd>
<p>
Calls <code>fai-class(1)</code> to define classes using scripts and files in
<em>$FAI/class</em> and classes from <em>/tmp/fai/additional-classes</em> and the
variable <code>$ADDCLASSES</code>. The list of all defined classes is stored in
the variable <code>$classes</code> and saved to <em>/tmp/fai/FAI_CLASSES</em>.
</p>
</dd>
<dt class="hdlist1">
defvar
</dt>
<dd>
<p>
Sources all files <em>$FAI/class/*.var</em> for every defined class. If a
hook has written some variable definitions to the file
<em>$LOGDIR/additional.var</em>, this file is also sourced.
</p>
</dd>
<dt class="hdlist1">
action
</dt>
<dd>
<p>
Depending on the value of <code>$FAI_ACTION</code> this subroutine decides which
action FAI should perform. The default available actions are:
<em>sysinfo</em>, <em>install</em>, <em>inventory</em>, <em>dirinstall</em> and <em>softupdate</em>.  If <code>$FAI_ACTION</code> has another
value, a user defined action is called if a file
<em>$FAI/hooks/$FAI_ACTION</em> exists. So you can easily define your own
actions.
</p>
</dd>
<dt class="hdlist1">
sysinfo
</dt>
<dd>
<p>
Called when no installation is performed but the action is
<em>sysinfo</em>. It shows information about the detected hardware and mounts
the local hard disks read only to <em>/target/<code>partitionname</code></em> or with
regard to a <em>fstab</em> file found inside a partition. Log files are
stored to the install server.
</p>
</dd>
<dt class="hdlist1">
inventory
</dt>
<dd>
<p>
A short list of system information is printed.
</p>
</dd>
<dt class="hdlist1">
install
</dt>
<dd>
<p>
This task controls the installation sequence. You will hear three
beeps before the installation starts. The major work is to call other
tasks and to save the output to <em>/tmp/fai/fai.log</em>. If you have any
problems during installation, look at all files in <em>/tmp/fai/</em>. You
can find examples of the log files
at <a href="http://fai-project.org/logs/">http://fai-project.org/logs/</a>.
</p>
</dd>
<dt class="hdlist1">
dirinstall
</dt>
<dd>
<p>
Install into a directory, not onto a local disk. Use this for creating
chroot environments.
</p>
</dd>
<dt class="hdlist1">
softupdate
</dt>
<dd>
<p>
This task, executed inside a running system via the <code>fai(8)</code> command
line interface, performs a softupdate.  See chapter <a href="#softupdate">[softupdate]</a> for
details.
</p>
</dd>
<dt class="hdlist1">
partition
</dt>
<dd>
<p>
Calls <code>setup-storage(8)</code> to partition the hard
disks and to create file systems. The task writes variable definitions
for the root and boot partition and device (<code>$ROOT_PARTITION,
$BOOT_PARTITION, $BOOT_DEVICE</code>) to <em>/tmp/fai/disk_var.sh</em> and creates
a <em>fstab</em> file for the new system.
</p>
</dd>
<dt class="hdlist1">
mountdisks
</dt>
<dd>
<p>
Mounts the created partitions according to the created
<em>/tmp/fai/fstab</em> file relative to <code>$FAI_ROOT</code>.
</p>
</dd>
<dt class="hdlist1">
extrbase
</dt>
<dd>
<p>
Extracts a minimal system after that a chroot can be made into it. By
default the base tar file <em>/var/tmp/base.tar.xz</em> will be
extracted. Also files matching a class name in $FAI/basefiles /` are used for unpacking a
different tar file depending on classes defined. This can be used for
installing different Linux distributions than the one used for
creating the nfsroot. The default file <em>base.tar.xz</em> is a snapshot of a
basic Debian system created by <code>debootstrap(8)</code>
This task uses the variable <code>FAI_BASEFILEURL</code> for fetching the base
file via FTP or HTTP if it’s defined.
</p>
</dd>
<dt class="hdlist1">
debconf
</dt>
<dd>
<p>
Calls <code>fai-debconf(1)</code> to set the values for the debconf preseeding database.
</p>
</dd>
<dt class="hdlist1">
repository
</dt>
<dd>
<p>
Prepare access to the package repository by preparing the apt
configuration. This can also add repository keys via
<code>apt-key(8)</code> in a class based manner from files like <em>CLASSNAME.asc</em>
in the directory <em>package_config</em>.
</p>
</dd>
<dt class="hdlist1">
updatebase
</dt>
<dd>
<p>
Updates the base packages of the new system and updates the list of
available packages. It also fakes some commands (called diversions)
inside the new installed system using <code>dpkg-divert(8)</code>, so no daemons
will be started during the installation.
</p>
</dd>
<dt class="hdlist1">
instsoft
</dt>
<dd>
<p>
Installs the desired software packages using class files in
<em>$FAI/package_config/</em>.
</p>
</dd>
<dt class="hdlist1">
configure
</dt>
<dd>
<p>
Calls scripts in <em>$FAI/scripts/</em> and its subdirectories for every
defined class.
</p>
</dd>
<dt class="hdlist1">
tests
</dt>
<dd>
<p>
Calls test scripts in <em>$FAI/tests/</em> and its subdirectories for every
defined class.
</p>
</dd>
<dt class="hdlist1">
finish
</dt>
<dd>
<p>
Unmounts all file systems in the new installed system and removes
diversions of files using the command <code>fai-divert</code>.
</p>
</dd>
<dt class="hdlist1">
chboot
</dt>
<dd>
<p>
Changes the PXE configuration for a host on the install server which
indicates which PXELINUX configuration to load on the next boot from network
card via TFTP. Therefore the <code>fai-chboot(8)</code> command is executed
remotely on the install server.
</p>
</dd>
<dt class="hdlist1">
savelog
</dt>
<dd>
<p>
Saves log files to local disk and to the account <code>$LOGUSER</code> on
<code>$LOGSERVER</code> (defaults to the install server).
</p>
</dd>
<dt class="hdlist1">
faiend
</dt>
<dd>
<p>
Wait for background jobs to finish (e.g. emacs compiling lisp files)
and automatically reboots the install clients or waits for manual
input before reboot.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_a_id_itests_a_automated_tests"><a id="itests"></a>Automated tests</h3>
<div class="paragraph"><p>After the customization scripts are executed, FAI will execute some
tests if available. Using these test, you can check for errors of the
installation. Test scripts are called via
<code>fai-do-scripts(1)</code> and should append its messages to
<em>$LOGDIR/test.log</em>. A Perl module including some useful subroutines
can be found in <em>Faitest.pm</em>. A test can also define a new class for
executing another tests during next boot via the variable
<code>$ADDCLASSES</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_autodiscover_a_autodiscover"><a id="autodiscover"></a> Autodiscover</h3>
<div class="paragraph"><p>In FAI 5.0 we released a feature that allows clients to search for the
faiserver in their respective subnetwork. This lifts the necessity of
having to collect every client’s MAC address and configuring the DHCP
daemon.</p></div>
<div class="paragraph"><p>This is done by booting from a small FAI autodiscover bootmedium (CD,
USB, etc.), which can be created via the command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# fai-cd -A autodiscover.iso</code></pre>
</div></div>
<div class="paragraph"><p>The image is roughly 25MB in size and scans the  subnet  for
a  FAI server. By  default it shows a menu with all profiles available
in the configuration space in the same manner as the <em>menu</em> flag
does. From this menu, you can select the installation type you wish to
perform.</p></div>
<div class="paragraph"><p>For the clients to find the faiserver, the faiserver must run
fai-monitor.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_changeboot_a_changing_the_boot_device"><a id="changeboot"></a>Changing the boot device</h3>
<div class="paragraph"><p>Changing the boot sequence is normally done in the BIOS setup. But you
can’t change the BIOS from a running Linux system.</p></div>
<div class="paragraph"><p>So, the boot sequence of the BIOS will remain unchanged and
your computer should always boot first from its network card and the
second boot device should be the local disk. Then you can
change the boot device of the client by creating different PXELINUX
configurations. This will define if an installation
should be performed, or if the client should to boot from local
disk. This is done using <code>fai-chboot(8)</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_debian_mirror_a_how_to_create_a_local_debian_mirror"><a id="debian-mirror"></a>How to create a local Debian mirror</h3>
<div class="paragraph"><p>The script <code>mkdebmirror</code> <span class="footnote" data-note="You can find the script in
&lt;em&gt;/usr/share/doc/fai-doc/examples/utils/&lt;/em&gt;">[<a id="_footnoteref_18" href="#_footnote_18" title="View footnote" class="footnote">18</a>]</span> can be used for creating
your own local Debian mirror. This script uses the command
<code>debmirror(1)</code>. A partial Debian mirror for i386 and amd64 architecture for
Debian 8.0 (aka jessie) without the source packages needs about
56GB of disk space. Accessing the mirror via HTTP will be the
default way in most cases. To see more output from the script call
<code>mkdebmirror -v</code>. A root account is not necessary to create and
maintain the Debian mirror.</p></div>
<div class="paragraph"><p>To use HTTP access to the local Debian mirror, install a web server
and create a symlink to the local directory where your mirror is
located:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver# apt-get install apache2
faiserver# ln -s /files/scratch/debmirror /var/www/html/debmirror</code></pre>
</div></div>
<div class="paragraph"><p>Create a file <code>sources.list(5)</code> in <em>/etc/fai/apt</em> which gives access
to your Debian mirror. Also add the IP-address of the
HTTP server to the variable <code>$NFSROOT_ETC_HOSTS</code> in
<em>nfsroot.conf</em> if the install clients have no DNS resolving.</p></div>
</div>
<div class="sect2">
<h3 id="_small_hints">Small hints</h3>
<div class="ulist"><ul>
<li>
<p>
When using HTTP access to a Debian mirror, the local <em>/var</em> partition
on all install clients must be big enough to keep the downloaded
Debian packages. Do not try with less than 250 Mbytes unless you know
why. You can limit the number of packages installed at a time with the
variable <code>$MAXPACKAGES</code>.
</p>
</li>
<li>
<p>
You can remove the red logo on the install client by simply calling
<code>reset</code> once. If will also not appear if you create a file using this
command on the install server:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>touch /srv/fai/nfsroot/.nocolorlogo</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
A list of variables used by FAI can be found at
<a href="http://wiki.fai-project.org/wiki/Variables">http://wiki.fai-project.org/wiki/Variables</a>.
</p>
</li>
<li>
<p>
You can shorten some customization scripts by using one single fcopy
command <em>fcopy -r /</em>.
</p>
</li>
<li>
<p>
If you rebuild the nfsroot, you will create a new ssh host key inside
the nfsroot. Then logging in to an install client may fail, because
the host key changes. You can use this:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>$ ssh -o StrictHostKeyChecking=no root@installclient</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
You can also delete the host entry on your install client in your
<em>~/.ssh/known_hosts</em> file by using the <em>ssh-keygen -R</em> command.
</p>
</li>
<li>
<p>
In the tasks chboot and savelog, a connection using secure shell is
opened to the FAI server (see <a href="#isavelog">[isavelog]</a>). To ensure that this works
non-interactively, a proper entry in <em>NFSROOT/root/.ssh/known_hosts</em>
must be created. When using fai-setup, this is done automatically, but
it may require manual editing in case the name of your FAI server was
not determined correctly.  If you stumble over ssh connections that
require typing "yes" to accept the host key during installation,
please check the contents of your <em>NFSROOT/root/.ssh/known_hosts file</em>
</p>
</li>
<li>
<p>
A list of all local hard disks is
stored in <code>$disklist</code>. It’s defined after <code>set_disk_info</code> is called.
</p>
</li>
<li>
<p>
Use <code>fai-divert -a</code> if a postinst script calls a configuration
program, e.g. the postinst script for package apache calls
apacheconfig, which needs manual input. You can fake the configuration
program so the installation can be fully automatic.
</p>
</li>
<li>
<p>
Sometimes the installation seems to stop, but often there’s only a
postinstall script of a software package that requires manual input
from the console. Change to another virtual terminal and look which
process is running with tools like <code>top(1)</code> and <code>pstree(1)</code>. You can
add <em>debug</em> to <em>FAI_FLAGS</em> to make the installation process show all
output from the postinst scripts on the console and get its input also
from the console.
</p>
</li>
<li>
<p>
How can I define classes on the kernel command line?
</p>
<div class="paragraph"><p>Read the man page of <code>fai-class(8)</code>. If you like to define some
additional classes (for e.g. A,B,C) on the kernel command line add this: <em>ADDCLASSES=A,B,C</em></p></div>
</li>
<li>
<p>
How to use a custom kernel inside the nfsroot?
</p>
<div class="paragraph"><p>Build your customized kernel by building a kernel package using
<code>make-kpkg(8)</code> and use the option <code>--initrd</code>. Copy this Debian package
to a local repository and add it to /etc/fai/sources.list. Add the
name of your package to /etc/fai/NFSROOT. Then call</p></div>
<div class="listingblock">
<div class="content">
<pre><code># fai-make-nfsroot -k</code></pre>
</div></div>
</li>
<li>
<p>
Can I use a 4.X kernel?
</p>
<div class="paragraph"><p>Yes. Using FAI 5.1 and dracut 044+150-1 overlayfs (instead of aufs) is
supported, so is kernel 4.x. When using Debian jessie, you may use a
kernel from backports or have a look at
<a href="https://lists.uni-koeln.de/pipermail/linux-fai/2016-March/011283.html">https://lists.uni-koeln.de/pipermail/linux-fai/2016-March/011283.html</a></p></div>
</li>
<li>
<p>
How to use the nfsroot as system for diskless clients?
</p>
<div class="paragraph"><p><a href="http://wiki.fai-project.org/wiki/Use_nfsroot_for_diskless_clients">http://wiki.fai-project.org/wiki/Use_nfsroot_for_diskless_clients</a></p></div>
</li>
<li>
<p>
How to server multiple nfsroot directories on one FAI server?
</p>
<div class="paragraph"><p>If you want to serve multiple nfsroot directories,
you need to create specific config directories in <em>/etc</em> for FAI, like
<em>/etc/fai-jessie</em> and <em>/etc/fai-stretch</em>. Then you need to set the
<code>$NFSROOT</code> variables to different directories and run</p></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>faiserver#fai-make-nfsroot -c /etc/fai-jessie</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_flag_reboot_fai_flags">flag_reboot (FAI_FLAGS)</h3>
<div class="paragraph"><p>If flag_reboot is set, by adding "reboot" to <code>$FAI_FLAGS</code>, your client
machine will reboot after the task faiend has finished. This is true
for network as well as bootmedium installations.</p></div>
</div>
<div class="sect2">
<h3 id="_centos_reboot">CentOS reboot</h3>
<div class="paragraph"><p>After the installation CentOS usually requires one additional reboot,
because of the SELinux security fixes that are applied post-installation.</p></div>
</div>
<div class="sect2">
<h3 id="_a_id_logfiles_a_log_files"><a id="logfiles"></a>Log files</h3>
<div class="paragraph"><p>FAI is creating several log files. During installation they are stored
in <em>/tmp/fai</em> on the install client itself. At the end of the
installation they will be copied to the install server (see
<a href="#isavelog">[isavelog]</a>). After the install client rebooted into his newly
installed system, you can find the FAI logs in <em>/var/log/fai</em>.
Log files are also created when doing the softupdate or dirinstall
action.</p></div>
<div class="paragraph"><p>On the faiserver, you can find the (remote) log files under the ~fai
directory.</p></div>
<div class="paragraph"><p>Sample log files from successfully installed computers are
available on <a href="http://fai-project.org/logs">http://fai-project.org/logs</a>.
These a some log files which are created by FAI.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
FAI_CLASSES
</dt>
<dd>
<p>
Contains a list of all classes defined.
</p>
</dd>
<dt class="hdlist1">
dmesg.log
</dt>
<dd>
<p>
Output of the <code>dmesg</code> command. Contains useful messages of the kernel
ring buffer.
</p>
</dd>
<dt class="hdlist1">
fai.log
</dt>
<dd>
<p>
The main log file. Contains all important information. You should
<strong>always</strong> read this file.
</p>
</dd>
<dt class="hdlist1">
boot.log
</dt>
<dd>
<p>
A list of variables of network parameters, mostly defined by the DHCP daemon.
</p>
</dd>
<dt class="hdlist1">
format.log
</dt>
<dd>
<p>
Output of the partition tool <code>setup-storage(8)</code>.
</p>
</dd>
<dt class="hdlist1">
shell.log
</dt>
<dd>
<p>
Output of all shell scripts, that are used for customization.
</p>
</dd>
<dt class="hdlist1">
variables.log
</dt>
<dd>
<p>
A list of all shell variables which are available during an
installation.
</p>
</dd>
<dt class="hdlist1">
error.log
</dt>
<dd>
<p>
A summary of possible errors in all log files.
</p>
</dd>
<dt class="hdlist1">
disk_var.sh
</dt>
<dd>
<p>
A list of variables that contain information about devices and
partitions to boot from, the root partition and a list of swap
devices. These information is used by some customization scripts
(e.g. <em>GRUB_PC/10-setup</em>).
</p>
</dd>
</dl></div>
<div class="paragraph"><p>If the installation process finishes, the hook <em>savelog.LAST.sh</em>
searches all log files for common errors and writes them to the file
<em>error.log</em>. So, you should first look into this file for errors. Also
the file <em>status.log</em> give you the exit code of the last command
executed in a script. To be sure, you should look for more details in
all log files.</p></div>
</div>
<div class="sect2">
<h3 id="_how_to_use_http_for_pxe_boot">How to use HTTP for PXE boot</h3>
<div class="listingblock">
<div class="content">
<pre><code>cp /usr/lib/PXELINUX/lpxelinux.0 /srv/tftp/fai/pxelinux.0</code></pre>
</div></div>
<div class="paragraph"><p>Enable HTTP access to the tftp directory:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>cd /var/www/html
ln -s /srv/tftp/fai</code></pre>
</div></div>
<div class="paragraph"><p>Add <em>-U URL</em> to the <em>fai-chboot</em> call. For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fai-chboot -U http://faiserver/fai -IFv .......</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_id_troubleshoot_a_troubleshooting"><a id="troubleshoot"></a>Troubleshooting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_id_booterror_a_boot_errors"><a id="booterror"></a>Boot errors</h3>
<div class="paragraph"><p>The following error message indicates that your install client doesn’t
get an answer from a DHCP server. Check your cables or start the
<code>dhcpd(8)</code> daemon with the debug flag enabled.</p></div>
<div class="quoteblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre><code>PXE-E51: No DHCP or BOOTP offers received
Network boot aborted</code></pre>
</div></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>If you do not see the following message, the install kernel could not
detect your network card, for example because of a missing driver:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth</code></pre>
</div></div>
<div class="paragraph"><p>Check the initrd in the nfsroot (<code>lsinird</code>) if the kernel driver of your network
card is included there and check if you like to add the package
<em>firmware-linux-nonfree</em> in <code>/etc/fai/NFSROOT</code> and rebuild the initrd
by calling <code>fai-make-nfsroot -k</code>.
You may also add a driver to <code>/srv/fai/nfsroot/etc/dracut.conf</code> in
the line <code>add_drivers</code>+<code>=</code>.</p></div>
<div class="paragraph"><p>This is the error message you will see, when your network card is
working, but the install server does not export the nfsroot
directory to the install clients, This is often caused by missing
NFS permissions on the server side.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Starting dhcp for interface eth0
dhcp: PREINIT eth0 up
dhcp: BOND setting eth
mount.nfs: access denied by server while mounting 192.168.33.250:/srv/fai/nfsroot
.
.
dracut Warning: Could not boot
.
Dropping to debug shell
dracut:/#</code></pre>
</div></div>
<div class="paragraph"><p>Now, you are inside the emergency shell of the initrd which was created
by <em>dracut(8)</em>. You will get a shell prompt, and can look at the log files.
For more information about debugging the early boot process using
dracut see <code>dracut.cmdline(7)</code></p></div>
<div class="paragraph"><p>Use the following command on the install server to see which directories are exported
from the install server (named faiserver):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ showmount -e faiserver</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr><div class="footnote" id="_footnote_1"><a href="#_footnoteref_1" title="Return to text">1</a>. Solaris 8 Advanced Installation Guide at
<a href="https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf">https://docs.oracle.com/cd/E19455-01/806-0957/806-0957.pdf</a>
</div><div class="footnote" id="_footnote_2"><a href="#_footnoteref_2" title="Return to text">2</a>. <a href="http://www.science.uva.nl/pub/solaris/auto-install">http://www.science.uva.nl/pub/solaris/auto-install</a></div><div class="footnote" id="_footnote_3"><a href="#_footnoteref_3" title="Return to text">3</a>. fai-kvm needs a lot of ram
for the vm, because of caching of /var, 2GB are OK</div><div class="footnote" id="_footnote_4"><a href="#_footnoteref_4" title="Return to text">4</a>. This installation will consume about 2GB of space in
<code>/tmp</code>.</div><div class="footnote" id="_footnote_5"><a href="#_footnoteref_5" title="Return to text">5</a>. It’s also possible to use only the configuration
file with the highest priority since the order of classes define a
priority from low to high within the list of classes.  </div><div class="footnote" id="_footnote_6"><a href="#_footnoteref_6" title="Return to text">6</a>. If you want to use a faster mirror, adjust the URL
  in <em>/etc/fai/apt/sources.list</em> and <code>FAI_DEBOOTSTRAP</code> in <em>/etc/fai/nfsroot.conf</em> before calling fai-setup.</div><div class="footnote" id="_footnote_7"><a href="#_footnoteref_7" title="Return to text">7</a>. This will call <code>fai-make-nfsroot(8)</code> internally.</div><div class="footnote" id="_footnote_8"><a href="#_footnoteref_8" title="Return to text">8</a>. These files need not belong to the root account.</div><div class="footnote" id="_footnote_9"><a href="#_footnoteref_9" title="Return to text">9</a>. You may also add this into your Domain Name System (DNS)</div><div class="footnote" id="_footnote_10"><a href="#_footnoteref_10" title="Return to text">10</a>. Since the root file system on the clients is mounted via
NFS, <code>fai</code> is located in
<em>/srv/fai/nfsroot/usr/sbin</em> on the install
server.</div><div class="footnote" id="_footnote_11"><a href="#_footnoteref_11" title="Return to text">11</a>. <em>$FAI</em> is an internal variable used by the FAI
scripts. By default the path is <em>/var/lib/fai/config</em>.</div><div class="footnote" id="_footnote_12"><a href="#_footnoteref_12" title="Return to text">12</a>. <em>/srv/fai/nfsroot</em> from the install
server via NFS</div><div class="footnote" id="_footnote_13"><a href="#_footnoteref_13" title="Return to text">13</a>. It it defined on the kernel command line</div><div class="footnote" id="_footnote_14"><a href="#_footnoteref_14" title="Return to text">14</a>. /var/lib/fai/config</div><div class="footnote" id="_footnote_15"><a href="#_footnoteref_15" title="Return to text">15</a>. <em>/var/log/fai/localhost/install/</em> is a link to this
directory.</div><div class="footnote" id="_footnote_16"><a href="#_footnoteref_16" title="Return to text">16</a>. I recommend to write the MAC
addresses (last three bytes will suffice if you have network cards
from the same vendor) and the host name in the front of each chassis.</div><div class="footnote" id="_footnote_17"><a href="#_footnoteref_17" title="Return to text">17</a>. For debugging purpose
it may help to enter the chroot environment manually using this
command.  <em>faiserver# chroot /srv/fai/nfsroot bash</em></div><div class="footnote" id="_footnote_18"><a href="#_footnoteref_18" title="Return to text">18</a>. You can find the script in
<em>/usr/share/doc/fai-doc/examples/utils/</em></div></div>
<div id="footer">
<div id="footer-text">
Version 5.3<br>
Last updated
 2017-01-24 15:09:25 CET
</div>
</div>


</body></html>